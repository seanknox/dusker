This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Dusker.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      Dusker.xcscheme
      DuskerWatch.xcscheme
  project.pbxproj
DuskerKit/
  Sources/
    DuskerKit/
      Extensions/
        Color+Extensions.swift
      Models/
        DuskerDataModel.xcdatamodeld/
          DuskerDataModel.xcdatamodel/
            contents
        README.md
        SurfSession.swift
        SurfSessionEntity.swift
        Wave.swift
        WaveEntity.swift
      Services/
        CoreDataManager.swift
        LocationService.swift
        SurfSessionStore.swift
      Utilities/
        DateUtilities.swift
        PreviewData.swift
  Tests/
    DuskerKitTests/
      CoreDataTests.swift
      DuskerKitTests.swift
  Package.swift
fastlane/
  Appfile
  Fastfile
iOS/
  Views/
    ContentView.swift
  DuskerApp.swift
  Info.plist
  LaunchScreen.storyboard
Shared/
  Resources/
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      PrimaryBackground.colorset/
        Contents.json
      TextDark.colorset/
        Contents.json
      TextLight.colorset/
        Contents.json
      Contents.json
Tests/
  iOS/
    DuskerTests.swift
  watchOS/
    DuskerWatchTests.swift
watchOS/
  Views/
    ContentView.swift
  DuskerApp.swift
  Info.plist
.gitignore
.ruby-version
.xcode-version
blueprint.md
Gemfile
project.yml
prompt_plan.md
README.md
SimulatorConfig.xcconfig
spec.md
todo.md

================================================================
Files
================================================================

================
File: Dusker.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

================
File: Dusker.xcodeproj/xcshareddata/xcschemes/Dusker.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1400"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      runPostActionsOnFailure = "NO">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "AE825F5BD5B41E21DB6E82B5"
               BuildableName = "Dusker.app"
               BlueprintName = "Dusker"
               ReferencedContainer = "container:Dusker.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      onlyGenerateCoverageForSpecifiedTargets = "NO">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "AE825F5BD5B41E21DB6E82B5"
            BuildableName = "Dusker.app"
            BlueprintName = "Dusker"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "87EEA91FF43B096FB8958218"
               BuildableName = "DuskerTests.xctest"
               BlueprintName = "DuskerTests"
               ReferencedContainer = "container:Dusker.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
      <CommandLineArguments>
      </CommandLineArguments>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "AE825F5BD5B41E21DB6E82B5"
            BuildableName = "Dusker.app"
            BlueprintName = "Dusker"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "AE825F5BD5B41E21DB6E82B5"
            BuildableName = "Dusker.app"
            BlueprintName = "Dusker"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: Dusker.xcodeproj/xcshareddata/xcschemes/DuskerWatch.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1400"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      runPostActionsOnFailure = "NO">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "7F61B1C2AF8E1C2F6B9DF692"
               BuildableName = "DuskerWatch.app"
               BlueprintName = "DuskerWatch"
               ReferencedContainer = "container:Dusker.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      onlyGenerateCoverageForSpecifiedTargets = "NO">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "7F61B1C2AF8E1C2F6B9DF692"
            BuildableName = "DuskerWatch.app"
            BlueprintName = "DuskerWatch"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "B5485B4918A630B9E1B59E55"
               BuildableName = "DuskerWatchTests.xctest"
               BlueprintName = "DuskerWatchTests"
               ReferencedContainer = "container:Dusker.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
      <CommandLineArguments>
      </CommandLineArguments>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <RemoteRunnable
         runnableDebuggingMode = "2"
         BundleIdentifier = "com.apple.Carousel">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "7F61B1C2AF8E1C2F6B9DF692"
            BuildableName = "DuskerWatch.app"
            BlueprintName = "DuskerWatch"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </RemoteRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "7F61B1C2AF8E1C2F6B9DF692"
            BuildableName = "DuskerWatch.app"
            BlueprintName = "DuskerWatch"
            ReferencedContainer = "container:Dusker.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: Dusker.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		02F577CE450C4D2796AB4FC3 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9A725333288DB4144AEB705F /* ContentView.swift */; };
		0A599514E26642D14158D1D8 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D82B079016A783B8B2736355 /* Assets.xcassets */; };
		124B168DB520F0F4D1EFC4AB /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D82B079016A783B8B2736355 /* Assets.xcassets */; };
		13E209A5E5C0552DB3556E74 /* DuskerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = B2985C2C6CB290757345F722 /* DuskerTests.swift */; };
		2547FFB80F7EA3F9447207C2 /* DuskerWatchExtension.appex in Embed Foundation Extensions */ = {isa = PBXBuildFile; fileRef = F4A28B6CBC6A25DC3F003BCE /* DuskerWatchExtension.appex */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
		542850D4B20A31DCD37FDD3F /* DuskerApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 05DA876529BA8C029DABDAF1 /* DuskerApp.swift */; };
		738D7C74DAA740F128BCEAF1 /* DuskerKit in Frameworks */ = {isa = PBXBuildFile; productRef = 2D48B9174BFBECB55B2DBDDF /* DuskerKit */; };
		8ADBD118827117306AA74B14 /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 6C2D0CBA9CF69AC6E1EAD32C /* LaunchScreen.storyboard */; };
		A75961394F3BCFE98C4B5003 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5ACA988CFEA2D177D3767663 /* ContentView.swift */; };
		AD63C2A7030CCDE9775CC4DF /* DuskerApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = BE0655AF2EC079AC19CE87BD /* DuskerApp.swift */; };
		B028D6271D48B63D6E79BBF8 /* DuskerKit in Frameworks */ = {isa = PBXBuildFile; productRef = 48B244DBA5CEF32B7E752673 /* DuskerKit */; };
		D7E4855AA1A8CD5AF0F808E5 /* DuskerWatchTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = FA31F2C52E14AF42FC36E3F9 /* DuskerWatchTests.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		1982BDFE09185CAD10FBA7EE /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E3BD4F94937D24770584A0E8 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = AE825F5BD5B41E21DB6E82B5;
			remoteInfo = Dusker;
		};
		38552C9F1346BD720DA8D9D5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E3BD4F94937D24770584A0E8 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 7425B7FBB55255A7AD3EF391;
			remoteInfo = DuskerWatchExtension;
		};
		6CDEF28AD660103B086CA0E2 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E3BD4F94937D24770584A0E8 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 7425B7FBB55255A7AD3EF391;
			remoteInfo = DuskerWatchExtension;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		B796907E4097FB8E70D7B06C /* Embed Foundation Extensions */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 13;
			files = (
				2547FFB80F7EA3F9447207C2 /* DuskerWatchExtension.appex in Embed Foundation Extensions */,
			);
			name = "Embed Foundation Extensions";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		018E1663A9795B6B09E7F3C7 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		05DA876529BA8C029DABDAF1 /* DuskerApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DuskerApp.swift; sourceTree = "<group>"; };
		230260BF62A8ECA1F4329C60 /* DuskerKit */ = {isa = PBXFileReference; lastKnownFileType = folder; name = DuskerKit; path = DuskerKit; sourceTree = SOURCE_ROOT; };
		243F8F905220C4D8A0322F59 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		4719ABA65087870AAF1F68CF /* Dusker.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = Dusker.app; sourceTree = BUILT_PRODUCTS_DIR; };
		5ACA988CFEA2D177D3767663 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		6C2D0CBA9CF69AC6E1EAD32C /* LaunchScreen.storyboard */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; path = LaunchScreen.storyboard; sourceTree = "<group>"; };
		9A725333288DB4144AEB705F /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		B17EAF926DEC92F2B629EE13 /* DuskerWatchTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = DuskerWatchTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		B2985C2C6CB290757345F722 /* DuskerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DuskerTests.swift; sourceTree = "<group>"; };
		BE0655AF2EC079AC19CE87BD /* DuskerApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DuskerApp.swift; sourceTree = "<group>"; };
		D82B079016A783B8B2736355 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		DBD685255D65FD883C230073 /* DuskerWatch.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = DuskerWatch.app; sourceTree = BUILT_PRODUCTS_DIR; };
		E11ACC8B5244D1593EA1DD1F /* DuskerTests.xctest */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.cfbundle; path = DuskerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		F4A28B6CBC6A25DC3F003BCE /* DuskerWatchExtension.appex */ = {isa = PBXFileReference; explicitFileType = "wrapper.app-extension"; includeInIndex = 0; path = DuskerWatchExtension.appex; sourceTree = BUILT_PRODUCTS_DIR; };
		FA31F2C52E14AF42FC36E3F9 /* DuskerWatchTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DuskerWatchTests.swift; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		15D967C4D90B8C9AEB764855 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				B028D6271D48B63D6E79BBF8 /* DuskerKit in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		7AD6FB3CD3B6A0543F0BEC84 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				738D7C74DAA740F128BCEAF1 /* DuskerKit in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		09135C2E44D9B41EE7028172 /* Utilities */ = {
			isa = PBXGroup;
			children = (
			);
			path = Utilities;
			sourceTree = "<group>";
		};
		09FB816E8780D14F9FF516AA /* Utilities */ = {
			isa = PBXGroup;
			children = (
			);
			path = Utilities;
			sourceTree = "<group>";
		};
		0D095D9587CD39004914B659 /* Utilities */ = {
			isa = PBXGroup;
			children = (
			);
			path = Utilities;
			sourceTree = "<group>";
		};
		150A4F57B95EE62AF8C0EABD /* Resources */ = {
			isa = PBXGroup;
			children = (
				D82B079016A783B8B2736355 /* Assets.xcassets */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		1D53292C9F2A3A6798BEF6B5 /* iOS */ = {
			isa = PBXGroup;
			children = (
				B2985C2C6CB290757345F722 /* DuskerTests.swift */,
			);
			name = iOS;
			path = Tests/iOS;
			sourceTree = "<group>";
		};
		24D44582342C0DBA62C1D7F3 /* watchOS */ = {
			isa = PBXGroup;
			children = (
				A8CB4DBCA04F351A4FF02EBC /* Extensions */,
				3F03EF523FEE5C52E809A924 /* Models */,
				CF18826F7A9E0B05B7E55AF4 /* Resources */,
				A2390302D544539CFC819081 /* Services */,
				0D095D9587CD39004914B659 /* Utilities */,
				80EBC55A5134AD440A55E98A /* ViewModels */,
				58E64720B9426FF257C2631F /* Views */,
				BE0655AF2EC079AC19CE87BD /* DuskerApp.swift */,
				018E1663A9795B6B09E7F3C7 /* Info.plist */,
			);
			path = watchOS;
			sourceTree = "<group>";
		};
		2CBB8CD6DEF03B1DD0623DE6 /* watchOS */ = {
			isa = PBXGroup;
			children = (
				FA31F2C52E14AF42FC36E3F9 /* DuskerWatchTests.swift */,
			);
			name = watchOS;
			path = Tests/watchOS;
			sourceTree = "<group>";
		};
		39206537B4D21CF602AFC3E1 /* iOS */ = {
			isa = PBXGroup;
			children = (
				E569FE9D8DE255F359F5DDDF /* Extensions */,
				CA901ED74F7BFA24752547F1 /* Models */,
				F4B565FA6724B26700CA87E9 /* Resources */,
				FEBBD27A9AFA3EC3047808D1 /* Services */,
				09FB816E8780D14F9FF516AA /* Utilities */,
				5DE020EBB1FE1EE332909B95 /* ViewModels */,
				7CCEA5BBE921A9DA354B2448 /* Views */,
				05DA876529BA8C029DABDAF1 /* DuskerApp.swift */,
				243F8F905220C4D8A0322F59 /* Info.plist */,
				6C2D0CBA9CF69AC6E1EAD32C /* LaunchScreen.storyboard */,
			);
			path = iOS;
			sourceTree = "<group>";
		};
		3F03EF523FEE5C52E809A924 /* Models */ = {
			isa = PBXGroup;
			children = (
			);
			path = Models;
			sourceTree = "<group>";
		};
		58E64720B9426FF257C2631F /* Views */ = {
			isa = PBXGroup;
			children = (
				9A725333288DB4144AEB705F /* ContentView.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		5DE020EBB1FE1EE332909B95 /* ViewModels */ = {
			isa = PBXGroup;
			children = (
			);
			path = ViewModels;
			sourceTree = "<group>";
		};
		60C0F56F4FEBA6CB9C209012 /* Shared */ = {
			isa = PBXGroup;
			children = (
				E1AEED5E25A590D91F8A7F3D /* Extensions */,
				C0222D2D5733CF61143AC37A /* Models */,
				150A4F57B95EE62AF8C0EABD /* Resources */,
				E3AF67F1D538461BE7A75E63 /* Services */,
				09135C2E44D9B41EE7028172 /* Utilities */,
				93302AB78A5459A2A0B9A02B /* ViewModels */,
				E09E147C027DD456760349CF /* Views */,
			);
			path = Shared;
			sourceTree = "<group>";
		};
		7CCEA5BBE921A9DA354B2448 /* Views */ = {
			isa = PBXGroup;
			children = (
				5ACA988CFEA2D177D3767663 /* ContentView.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		80EBC55A5134AD440A55E98A /* ViewModels */ = {
			isa = PBXGroup;
			children = (
			);
			path = ViewModels;
			sourceTree = "<group>";
		};
		850DDAD8AB74DBCF5F5AC6FC /* Products */ = {
			isa = PBXGroup;
			children = (
				4719ABA65087870AAF1F68CF /* Dusker.app */,
				E11ACC8B5244D1593EA1DD1F /* DuskerTests.xctest */,
				DBD685255D65FD883C230073 /* DuskerWatch.app */,
				F4A28B6CBC6A25DC3F003BCE /* DuskerWatchExtension.appex */,
				B17EAF926DEC92F2B629EE13 /* DuskerWatchTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		93302AB78A5459A2A0B9A02B /* ViewModels */ = {
			isa = PBXGroup;
			children = (
			);
			path = ViewModels;
			sourceTree = "<group>";
		};
		A2390302D544539CFC819081 /* Services */ = {
			isa = PBXGroup;
			children = (
			);
			path = Services;
			sourceTree = "<group>";
		};
		A8CB4DBCA04F351A4FF02EBC /* Extensions */ = {
			isa = PBXGroup;
			children = (
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		B87F8C86A3859FDEBFABDB7F = {
			isa = PBXGroup;
			children = (
				39206537B4D21CF602AFC3E1 /* iOS */,
				1D53292C9F2A3A6798BEF6B5 /* iOS */,
				E4B8A07BCA6308A11E7F4D8E /* Packages */,
				60C0F56F4FEBA6CB9C209012 /* Shared */,
				24D44582342C0DBA62C1D7F3 /* watchOS */,
				2CBB8CD6DEF03B1DD0623DE6 /* watchOS */,
				850DDAD8AB74DBCF5F5AC6FC /* Products */,
			);
			sourceTree = "<group>";
		};
		C0222D2D5733CF61143AC37A /* Models */ = {
			isa = PBXGroup;
			children = (
			);
			path = Models;
			sourceTree = "<group>";
		};
		CA901ED74F7BFA24752547F1 /* Models */ = {
			isa = PBXGroup;
			children = (
			);
			path = Models;
			sourceTree = "<group>";
		};
		CF18826F7A9E0B05B7E55AF4 /* Resources */ = {
			isa = PBXGroup;
			children = (
			);
			path = Resources;
			sourceTree = "<group>";
		};
		E09E147C027DD456760349CF /* Views */ = {
			isa = PBXGroup;
			children = (
			);
			path = Views;
			sourceTree = "<group>";
		};
		E1AEED5E25A590D91F8A7F3D /* Extensions */ = {
			isa = PBXGroup;
			children = (
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		E3AF67F1D538461BE7A75E63 /* Services */ = {
			isa = PBXGroup;
			children = (
			);
			path = Services;
			sourceTree = "<group>";
		};
		E4B8A07BCA6308A11E7F4D8E /* Packages */ = {
			isa = PBXGroup;
			children = (
				230260BF62A8ECA1F4329C60 /* DuskerKit */,
			);
			name = Packages;
			sourceTree = "<group>";
		};
		E569FE9D8DE255F359F5DDDF /* Extensions */ = {
			isa = PBXGroup;
			children = (
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		F4B565FA6724B26700CA87E9 /* Resources */ = {
			isa = PBXGroup;
			children = (
			);
			path = Resources;
			sourceTree = "<group>";
		};
		FEBBD27A9AFA3EC3047808D1 /* Services */ = {
			isa = PBXGroup;
			children = (
			);
			path = Services;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		7425B7FBB55255A7AD3EF391 /* DuskerWatchExtension */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 1D057924C602A644064E6D92 /* Build configuration list for PBXNativeTarget "DuskerWatchExtension" */;
			buildPhases = (
				E3CC10ABCE5509236A678027 /* Sources */,
				547A69B93BA3AB8205A4BE75 /* Resources */,
				7AD6FB3CD3B6A0543F0BEC84 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = DuskerWatchExtension;
			packageProductDependencies = (
				2D48B9174BFBECB55B2DBDDF /* DuskerKit */,
			);
			productName = DuskerWatchExtension;
			productReference = F4A28B6CBC6A25DC3F003BCE /* DuskerWatchExtension.appex */;
			productType = "com.apple.product-type.watchkit2-extension";
		};
		7F61B1C2AF8E1C2F6B9DF692 /* DuskerWatch */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 9D6F3690DAF90F9D60A085FF /* Build configuration list for PBXNativeTarget "DuskerWatch" */;
			buildPhases = (
				B796907E4097FB8E70D7B06C /* Embed Foundation Extensions */,
			);
			buildRules = (
			);
			dependencies = (
				7F3D05213AD609FBCF3A80E8 /* PBXTargetDependency */,
			);
			name = DuskerWatch;
			productName = DuskerWatch;
			productReference = DBD685255D65FD883C230073 /* DuskerWatch.app */;
			productType = "com.apple.product-type.application.watchapp2";
		};
		87EEA91FF43B096FB8958218 /* DuskerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = AE7FD01A568C2B25642BE1F1 /* Build configuration list for PBXNativeTarget "DuskerTests" */;
			buildPhases = (
				353158534737F6EB3F5A1605 /* Sources */,
			);
			buildRules = (
			);
			dependencies = (
				E3B8AC0DE41DFC11AC99DD2E /* PBXTargetDependency */,
			);
			name = DuskerTests;
			productName = DuskerTests;
			productReference = E11ACC8B5244D1593EA1DD1F /* DuskerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		AE825F5BD5B41E21DB6E82B5 /* Dusker */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 54D44AB96E643C39A7980EBE /* Build configuration list for PBXNativeTarget "Dusker" */;
			buildPhases = (
				5C7582C4E9620220F4164ED2 /* Sources */,
				BC68146B451F6454A5914AAF /* Resources */,
				15D967C4D90B8C9AEB764855 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Dusker;
			packageProductDependencies = (
				48B244DBA5CEF32B7E752673 /* DuskerKit */,
			);
			productName = Dusker;
			productReference = 4719ABA65087870AAF1F68CF /* Dusker.app */;
			productType = "com.apple.product-type.application";
		};
		B5485B4918A630B9E1B59E55 /* DuskerWatchTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FE00C8071BF3166BF15A976D /* Build configuration list for PBXNativeTarget "DuskerWatchTests" */;
			buildPhases = (
				FEB29D5EAA3DE8E418D87A06 /* Sources */,
			);
			buildRules = (
			);
			dependencies = (
				B11ED6A7F018375D87D9DAB6 /* PBXTargetDependency */,
			);
			name = DuskerWatchTests;
			productName = DuskerWatchTests;
			productReference = B17EAF926DEC92F2B629EE13 /* DuskerWatchTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		E3BD4F94937D24770584A0E8 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1400;
				TargetAttributes = {
					7425B7FBB55255A7AD3EF391 = {
						DevelopmentTeam = "";
						ProvisioningStyle = Automatic;
					};
					7F61B1C2AF8E1C2F6B9DF692 = {
						DevelopmentTeam = "";
						ProvisioningStyle = Automatic;
					};
					87EEA91FF43B096FB8958218 = {
						DevelopmentTeam = "";
						ProvisioningStyle = Automatic;
					};
					AE825F5BD5B41E21DB6E82B5 = {
						DevelopmentTeam = "";
						ProvisioningStyle = Automatic;
					};
					B5485B4918A630B9E1B59E55 = {
						DevelopmentTeam = "";
						ProvisioningStyle = Automatic;
					};
				};
			};
			buildConfigurationList = D2B3663D222D20AC1D43F003 /* Build configuration list for PBXProject "Dusker" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				Base,
				en,
			);
			mainGroup = B87F8C86A3859FDEBFABDB7F;
			packageReferences = (
				4F4E6AC68C82BEAB713B72F9 /* XCLocalSwiftPackageReference "./DuskerKit" */,
			);
			projectDirPath = "";
			projectRoot = "";
			targets = (
				AE825F5BD5B41E21DB6E82B5 /* Dusker */,
				87EEA91FF43B096FB8958218 /* DuskerTests */,
				7F61B1C2AF8E1C2F6B9DF692 /* DuskerWatch */,
				7425B7FBB55255A7AD3EF391 /* DuskerWatchExtension */,
				B5485B4918A630B9E1B59E55 /* DuskerWatchTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		547A69B93BA3AB8205A4BE75 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				124B168DB520F0F4D1EFC4AB /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		BC68146B451F6454A5914AAF /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				0A599514E26642D14158D1D8 /* Assets.xcassets in Resources */,
				8ADBD118827117306AA74B14 /* LaunchScreen.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		353158534737F6EB3F5A1605 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				13E209A5E5C0552DB3556E74 /* DuskerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		5C7582C4E9620220F4164ED2 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A75961394F3BCFE98C4B5003 /* ContentView.swift in Sources */,
				542850D4B20A31DCD37FDD3F /* DuskerApp.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E3CC10ABCE5509236A678027 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				02F577CE450C4D2796AB4FC3 /* ContentView.swift in Sources */,
				AD63C2A7030CCDE9775CC4DF /* DuskerApp.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FEB29D5EAA3DE8E418D87A06 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				D7E4855AA1A8CD5AF0F808E5 /* DuskerWatchTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		7F3D05213AD609FBCF3A80E8 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 7425B7FBB55255A7AD3EF391 /* DuskerWatchExtension */;
			targetProxy = 38552C9F1346BD720DA8D9D5 /* PBXContainerItemProxy */;
		};
		B11ED6A7F018375D87D9DAB6 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 7425B7FBB55255A7AD3EF391 /* DuskerWatchExtension */;
			targetProxy = 6CDEF28AD660103B086CA0E2 /* PBXContainerItemProxy */;
		};
		E3B8AC0DE41DFC11AC99DD2E /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = AE825F5BD5B41E21DB6E82B5 /* Dusker */;
			targetProxy = 1982BDFE09185CAD10FBA7EE /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		117914A9490E5F35C508F88E /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"DEBUG=1",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 16.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				WATCHOS_DEPLOYMENT_TARGET = 9.0;
			};
			name = Debug;
		};
		1EC9044530E9A1755BA39E41 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 16.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				SWIFT_VERSION = 5.0;
				WATCHOS_DEPLOYMENT_TARGET = 9.0;
			};
			name = Release;
		};
		53F288C322A144387449674C /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				GENERATE_INFOPLIST_FILE = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp.watchkitextension.tests;
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Release;
		};
		6C21AD73CAB803B5779DA7E5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = watchOS/Info.plist;
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp;
				PRODUCT_NAME = DuskerWatch;
				SDKROOT = watchos;
				SKIP_INSTALL = NO;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Release;
		};
		74F354C732986C13ED1B9A23 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_COMPLICATION_NAME = Complication;
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = watchOS/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp.watchkitextension;
				PRODUCT_NAME = DuskerWatchExtension;
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Debug;
		};
		8987AD64EDB4992A6C2BAD0E /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = iOS/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		8B6B3B1C921BE04C68F62166 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = iOS/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		D4A3379A9C689531EAE1AAA6 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = watchOS/Info.plist;
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp;
				PRODUCT_NAME = DuskerWatch;
				SDKROOT = watchos;
				SKIP_INSTALL = NO;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Debug;
		};
		D5E3350432B1157DAB0AC3B6 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				GENERATE_INFOPLIST_FILE = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp.watchkitextension.tests;
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Debug;
		};
		E6CF2D29B706AC8DD92AE52E /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_COMPLICATION_NAME = Complication;
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = watchOS/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@executable_path/../../Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.watchkitapp.watchkitextension;
				PRODUCT_NAME = DuskerWatchExtension;
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				TARGETED_DEVICE_FAMILY = 4;
			};
			name = Release;
		};
		E82FE160226B1A80C2E340B7 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				GENERATE_INFOPLIST_FILE = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.tests;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Dusker.app/Dusker";
			};
			name = Release;
		};
		F69528D3526D81CE36B991D4 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = "";
				GENERATE_INFOPLIST_FILE = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.dusker.ios.tests;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Dusker.app/Dusker";
			};
			name = Debug;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		1D057924C602A644064E6D92 /* Build configuration list for PBXNativeTarget "DuskerWatchExtension" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				74F354C732986C13ED1B9A23 /* Debug */,
				E6CF2D29B706AC8DD92AE52E /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		54D44AB96E643C39A7980EBE /* Build configuration list for PBXNativeTarget "Dusker" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				8B6B3B1C921BE04C68F62166 /* Debug */,
				8987AD64EDB4992A6C2BAD0E /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		9D6F3690DAF90F9D60A085FF /* Build configuration list for PBXNativeTarget "DuskerWatch" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				D4A3379A9C689531EAE1AAA6 /* Debug */,
				6C21AD73CAB803B5779DA7E5 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		AE7FD01A568C2B25642BE1F1 /* Build configuration list for PBXNativeTarget "DuskerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				F69528D3526D81CE36B991D4 /* Debug */,
				E82FE160226B1A80C2E340B7 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		D2B3663D222D20AC1D43F003 /* Build configuration list for PBXProject "Dusker" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				117914A9490E5F35C508F88E /* Debug */,
				1EC9044530E9A1755BA39E41 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		FE00C8071BF3166BF15A976D /* Build configuration list for PBXNativeTarget "DuskerWatchTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				D5E3350432B1157DAB0AC3B6 /* Debug */,
				53F288C322A144387449674C /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
/* End XCConfigurationList section */

/* Begin XCLocalSwiftPackageReference section */
		4F4E6AC68C82BEAB713B72F9 /* XCLocalSwiftPackageReference "./DuskerKit" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = ./DuskerKit;
		};
/* End XCLocalSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		2D48B9174BFBECB55B2DBDDF /* DuskerKit */ = {
			isa = XCSwiftPackageProductDependency;
			productName = DuskerKit;
		};
		48B244DBA5CEF32B7E752673 /* DuskerKit */ = {
			isa = XCSwiftPackageProductDependency;
			productName = DuskerKit;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = E3BD4F94937D24770584A0E8 /* Project object */;
}

================
File: DuskerKit/Sources/DuskerKit/Extensions/Color+Extensions.swift
================
import SwiftUI

#if canImport(UIKit)
import UIKit
#elseif canImport(AppKit)
import AppKit
#endif

@available(iOS 13.0, watchOS 6.0, macOS 10.15, *)
public extension Color {
    static let primaryBackground = Color("PrimaryBackground")
    static let accentColor = Color("AccentColor")
    static let textLight = Color("TextLight")
    static let textDark = Color("TextDark")
    
    #if canImport(UIKit)
    func toUIColor() -> UIColor {
        UIColor(self)
    }
    #elseif canImport(AppKit)
    @available(macOS 11.0, *)
    func toNSColor() -> NSColor {
        NSColor(self)
    }
    #endif
}

================
File: DuskerKit/Sources/DuskerKit/Models/DuskerDataModel.xcdatamodeld/DuskerDataModel.xcdatamodel/contents
================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="21754" systemVersion="22G91" minimumToolsVersion="Automatic" sourceLanguage="Swift" userDefinedModelVersionIdentifier="">
    <entity name="SurfSession" representedClassName="SurfSessionEntity" syncable="YES">
        <attribute name="avgHeartRate" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="distancePaddled" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="distanceSurfed" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="endDate" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="id" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="isUploaded" attributeType="Boolean" defaultValueString="NO" usesScalarValueType="YES"/>
        <attribute name="latitude" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="location" attributeType="String" defaultValueString=""/>
        <attribute name="longitude" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="maxSpeed" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="notes" optional="YES" attributeType="String"/>
        <attribute name="startDate" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="strokeCount" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
        <attribute name="totalWaves" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
        <relationship name="waves" optional="YES" toMany="YES" deletionRule="Cascade" destinationEntity="Wave" inverseName="session" inverseEntity="Wave"/>
        <uniquenessConstraints>
            <uniquenessConstraint>
                <constraint value="id"/>
            </uniquenessConstraint>
        </uniquenessConstraints>
    </entity>
    <entity name="Wave" representedClassName="WaveEntity" syncable="YES">
        <attribute name="confidence" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="coordinates" optional="YES" attributeType="Binary"/>
        <attribute name="distance" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="duration" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="endTime" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="id" attributeType="UUID" usesScalarValueType="NO"/>
        <attribute name="maxSpeed" optional="YES" attributeType="Double" defaultValueString="0.0" usesScalarValueType="YES"/>
        <attribute name="startTime" attributeType="Date" usesScalarValueType="NO"/>
        <relationship name="session" optional="YES" maxCount="1" deletionRule="Nullify" destinationEntity="SurfSession" inverseName="waves" inverseEntity="SurfSession"/>
        <uniquenessConstraints>
            <uniquenessConstraint>
                <constraint value="id"/>
            </uniquenessConstraint>
        </uniquenessConstraints>
    </entity>
</model>

================
File: DuskerKit/Sources/DuskerKit/Models/README.md
================
# Dusker Core Data Models

This directory contains the Core Data models for the Dusker app, which are used to store surf session data.

## Model Structure

### SurfSession Entity
- Represents a surf session with attributes like start/end time, location, and performance metrics
- Has a one-to-many relationship with Wave entities
- Includes computed properties for derived metrics like duration

### Wave Entity
- Represents an individual wave ridden during a surf session
- Stores data like start/end time, distance, speed, and GPS coordinates
- Has a many-to-one relationship with SurfSession

## Usage Examples

### Initialize Core Data
```swift
// Access the shared CoreDataManager
let coreDataManager = CoreDataManager.shared

// Get the view context
let context = coreDataManager.viewContext
```

### Create and Save a Surf Session
```swift
// Using SurfSessionStore
let sessionStore = SurfSessionStore()
let newSession = sessionStore.createSession(
    startDate: Date(),
    location: "Malibu Beach",
    latitude: 34.0259,
    longitude: -118.7798
)

// Or manually
let session = SurfSessionEntity(context: context)
session.id = UUID()
session.startDate = Date()
session.location = "Malibu Beach"
// Set other properties...
try? context.save()
```

### Add Waves to a Session
```swift
// Using SurfSessionStore
let wave = sessionStore.addWave(
    toSession: session,
    startTime: Date(),
    endTime: Date().addingTimeInterval(30),
    distance: 150.0,
    duration: 30.0,
    maxSpeed: 15.0,
    coordinates: coordinatesData,
    confidence: 0.95
)

// Or manually
let wave = WaveEntity(context: context)
wave.id = UUID()
wave.startTime = Date()
wave.endTime = Date().addingTimeInterval(30)
wave.session = session
// Set other properties...
try? context.save()
```

### Fetch Sessions and Waves
```swift
// Get all sessions
let allSessions = sessionStore.getAllSessions()

// Get a specific session
if let session = sessionStore.getSession(withId: sessionId) {
    // Access session properties
    print(session.location)
    print(session.formattedDuration)
    
    // Access waves
    for wave in session.wavesArray {
        print(wave.maxSpeed)
    }
}

// Get waves for a session
let waves = sessionStore.getWavesForSession(withId: sessionId)
```

### Delete a Session
```swift
// This will also delete all associated waves due to cascade delete rule
sessionStore.deleteSession(session)
```

## Preview Data

For SwiftUI previews and testing, use the PreviewData class:

```swift
// Create a preview context with sample data
let previewContext = PreviewData.createPreviewContext()
PreviewData.createSampleData(in: previewContext)

// Use in SwiftUI previews
struct MyView_Previews: PreviewProvider {
    static var previews: some View {
        let context = PreviewData.createPreviewContext()
        PreviewData.createSampleData(in: context)
        return MyView().environment(\.managedObjectContext, context)
    }
}
```

================
File: DuskerKit/Sources/DuskerKit/Models/SurfSession.swift
================
import Foundation

public struct SurfSession: Identifiable, Codable {
    public let id: UUID
    public let startDate: Date
    public var endDate: Date?
    public var location: String
    public var latitude: Double
    public var longitude: Double
    public var totalWaves: Int
    public var maxSpeed: Double
    public var avgHeartRate: Double
    public var distanceSurfed: Double
    public var distancePaddled: Double
    public var strokeCount: Int
    public var notes: String?
    public var isUploaded: Bool
    
    public init(
        id: UUID = UUID(),
        startDate: Date = Date(),
        endDate: Date? = nil,
        location: String = "",
        latitude: Double = 0.0,
        longitude: Double = 0.0,
        totalWaves: Int = 0,
        maxSpeed: Double = 0.0,
        avgHeartRate: Double = 0.0,
        distanceSurfed: Double = 0.0,
        distancePaddled: Double = 0.0,
        strokeCount: Int = 0,
        notes: String? = nil,
        isUploaded: Bool = false
    ) {
        self.id = id
        self.startDate = startDate
        self.endDate = endDate
        self.location = location
        self.latitude = latitude
        self.longitude = longitude
        self.totalWaves = totalWaves
        self.maxSpeed = maxSpeed
        self.avgHeartRate = avgHeartRate
        self.distanceSurfed = distanceSurfed
        self.distancePaddled = distancePaddled
        self.strokeCount = strokeCount
        self.notes = notes
        self.isUploaded = isUploaded
    }
    
    // Computed properties
    public var duration: TimeInterval {
        guard let end = endDate else { return Date().timeIntervalSince(startDate) }
        return end.timeIntervalSince(startDate)
    }
    
    public var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: duration) ?? "0s"
    }
}

================
File: DuskerKit/Sources/DuskerKit/Models/SurfSessionEntity.swift
================
import Foundation
import CoreData

@objc(SurfSessionEntity)
public class SurfSessionEntity: NSManagedObject, Identifiable {
    @NSManaged public var id: UUID
    @NSManaged public var startDate: Date
    @NSManaged public var endDate: Date?
    @NSManaged public var location: String
    @NSManaged public var latitude: Double
    @NSManaged public var longitude: Double
    @NSManaged public var totalWaves: Int32
    @NSManaged public var maxSpeed: Double
    @NSManaged public var avgHeartRate: Double
    @NSManaged public var distanceSurfed: Double
    @NSManaged public var distancePaddled: Double
    @NSManaged public var strokeCount: Int32
    @NSManaged public var notes: String?
    @NSManaged public var isUploaded: Bool
    @NSManaged public var waves: Set<WaveEntity>?
    
    // MARK: - Computed Properties
    
    public var duration: TimeInterval {
        guard let end = endDate else { return Date().timeIntervalSince(startDate) }
        return end.timeIntervalSince(startDate)
    }
    
    public var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: duration) ?? "0s"
    }
    
    public var wavesArray: [WaveEntity] {
        let set = waves ?? []
        return set.sorted { $0.startTime < $1.startTime }
    }
    
    // MARK: - Conversion Methods
    
    public func toSurfSession() -> SurfSession {
        return SurfSession(
            id: id,
            startDate: startDate,
            endDate: endDate,
            location: location,
            latitude: latitude,
            longitude: longitude,
            totalWaves: Int(totalWaves),
            maxSpeed: maxSpeed,
            avgHeartRate: avgHeartRate,
            distanceSurfed: distanceSurfed,
            distancePaddled: distancePaddled,
            strokeCount: Int(strokeCount),
            notes: notes,
            isUploaded: isUploaded
        )
    }
}

// MARK: - Fetch Request Extensions

extension SurfSessionEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<SurfSessionEntity> {
        return NSFetchRequest<SurfSessionEntity>(entityName: "SurfSession")
    }
    
    public class func fetchAll(in context: NSManagedObjectContext) -> [SurfSessionEntity] {
        let request = fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \SurfSessionEntity.startDate, ascending: false)]
        
        do {
            return try context.fetch(request)
        } catch {
            print("Error fetching surf sessions: \(error)")
            return []
        }
    }
    
    public class func fetch(withId id: UUID, in context: NSManagedObjectContext) -> SurfSessionEntity? {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", id as CVarArg)
        request.fetchLimit = 1
        
        do {
            let results = try context.fetch(request)
            return results.first
        } catch {
            print("Error fetching surf session with id \(id): \(error)")
            return nil
        }
    }
}

================
File: DuskerKit/Sources/DuskerKit/Models/Wave.swift
================
import Foundation

public struct Wave: Identifiable, Codable {
    public let id: UUID
    public let startTime: Date
    public var endTime: Date
    public var distance: Double
    public var duration: Double
    public var maxSpeed: Double
    public var coordinates: Data
    public var confidence: Double
    
    public init(
        id: UUID = UUID(),
        startTime: Date = Date(),
        endTime: Date = Date().addingTimeInterval(30),
        distance: Double = 0.0,
        duration: Double = 0.0,
        maxSpeed: Double = 0.0,
        coordinates: Data = Data(),
        confidence: Double = 1.0
    ) {
        self.id = id
        self.startTime = startTime
        self.endTime = endTime
        self.distance = distance
        self.duration = duration
        self.maxSpeed = maxSpeed
        self.coordinates = coordinates
        self.confidence = confidence
    }
    
    // Computed properties
    public var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: duration) ?? "0s"
    }
    
    public var averageSpeed: Double {
        return distance / duration
    }
}

================
File: DuskerKit/Sources/DuskerKit/Models/WaveEntity.swift
================
import Foundation
import CoreData

@objc(WaveEntity)
public class WaveEntity: NSManagedObject, Identifiable {
    @NSManaged public var id: UUID
    @NSManaged public var startTime: Date
    @NSManaged public var endTime: Date
    @NSManaged public var distance: Double
    @NSManaged public var duration: Double
    @NSManaged public var maxSpeed: Double
    @NSManaged public var coordinates: Data
    @NSManaged public var confidence: Double
    @NSManaged public var session: SurfSessionEntity?
    
    // MARK: - Computed Properties
    
    public var formattedDuration: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: duration) ?? "0s"
    }
    
    public var averageSpeed: Double {
        return distance / duration
    }
    
    // MARK: - Conversion Methods
    
    public func toWave() -> Wave {
        return Wave(
            id: id,
            startTime: startTime,
            endTime: endTime,
            distance: distance,
            duration: duration,
            maxSpeed: maxSpeed,
            coordinates: coordinates,
            confidence: confidence
        )
    }
}

// MARK: - Fetch Request Extensions

extension WaveEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<WaveEntity> {
        return NSFetchRequest<WaveEntity>(entityName: "Wave")
    }
    
    public class func fetchAll(in context: NSManagedObjectContext) -> [WaveEntity] {
        let request = fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \WaveEntity.startTime, ascending: false)]
        
        do {
            return try context.fetch(request)
        } catch {
            print("Error fetching waves: \(error)")
            return []
        }
    }
    
    public class func fetch(withId id: UUID, in context: NSManagedObjectContext) -> WaveEntity? {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", id as CVarArg)
        request.fetchLimit = 1
        
        do {
            let results = try context.fetch(request)
            return results.first
        } catch {
            print("Error fetching wave with id \(id): \(error)")
            return nil
        }
    }
    
    public class func fetchWaves(forSessionId sessionId: UUID, in context: NSManagedObjectContext) -> [WaveEntity] {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "session.id == %@", sessionId as CVarArg)
        request.sortDescriptors = [NSSortDescriptor(keyPath: \WaveEntity.startTime, ascending: true)]
        
        do {
            return try context.fetch(request)
        } catch {
            print("Error fetching waves for session \(sessionId): \(error)")
            return []
        }
    }
}

================
File: DuskerKit/Sources/DuskerKit/Services/CoreDataManager.swift
================
import Foundation
import CoreData

public class CoreDataManager {
    public static let shared = CoreDataManager()
    
    private let modelName = "DuskerDataModel"
    
    public lazy var persistentContainer: NSPersistentContainer = {
        // Look for the model in the bundle
        guard let modelURL = Bundle.module.url(forResource: modelName, withExtension: "momd") else {
            // If not found, try to find the xcdatamodeld directly
            guard let modelURL = Bundle.module.url(forResource: modelName, withExtension: "xcdatamodeld") else {
                fatalError("Failed to find Core Data model named \(modelName)")
            }
            
            guard let mom = NSManagedObjectModel(contentsOf: modelURL) else {
                fatalError("Failed to create model from file at \(modelURL)")
            }
            
            let container = NSPersistentContainer(name: modelName, managedObjectModel: mom)
            container.loadPersistentStores { (storeDescription, error) in
                if let error = error as NSError? {
                    fatalError("Unresolved error \(error), \(error.userInfo)")
                }
            }
            container.viewContext.automaticallyMergesChangesFromParent = true
            container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
            return container
        }
        
        guard let mom = NSManagedObjectModel(contentsOf: modelURL) else {
            fatalError("Failed to create model from file at \(modelURL)")
        }
        
        let container = NSPersistentContainer(name: modelName, managedObjectModel: mom)
        container.loadPersistentStores { (storeDescription, error) in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return container
    }()
    
    public var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    // Make init internal so it can be overridden by subclasses in the same module
    internal init() {}
    
    // MARK: - Helper Methods
    
    public func saveContext() {
        let context = viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }
    
    // Create a background context for performing operations off the main thread
    public func backgroundContext() -> NSManagedObjectContext {
        let context = persistentContainer.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }
}

================
File: DuskerKit/Sources/DuskerKit/Services/LocationService.swift
================
import Foundation
import CoreLocation
import Combine

@available(iOS 13.0, watchOS 6.0, macOS 10.15, *)
public class LocationService: NSObject, ObservableObject {
    private let locationManager = CLLocationManager()
    
    @Published public var currentLocation: CLLocation?
    @Published public var authorizationStatus: CLAuthorizationStatus
    
    public override init() {
        authorizationStatus = .notDetermined
        
        super.init()
        
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.distanceFilter = 5 // meters
    }
    
    public func requestAuthorization() {
        locationManager.requestWhenInUseAuthorization()
    }
    
    public func requestAlwaysAuthorization() {
        locationManager.requestAlwaysAuthorization()
    }
    
    public func startUpdatingLocation() {
        locationManager.startUpdatingLocation()
    }
    
    public func stopUpdatingLocation() {
        locationManager.stopUpdatingLocation()
    }
}

@available(iOS 13.0, watchOS 6.0, macOS 10.15, *)
extension LocationService: CLLocationManagerDelegate {
    public func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        currentLocation = location
    }
    
    public func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        authorizationStatus = status
    }
    
    public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }
}

================
File: DuskerKit/Sources/DuskerKit/Services/SurfSessionStore.swift
================
import Foundation
import CoreData

public class SurfSessionStore {
    private let coreDataManager: CoreDataManager
    
    public init(coreDataManager: CoreDataManager = .shared) {
        self.coreDataManager = coreDataManager
    }
    
    // MARK: - Session Operations
    
    public func createSession(
        startDate: Date = Date(),
        endDate: Date? = nil,
        location: String = "",
        latitude: Double = 0.0,
        longitude: Double = 0.0,
        totalWaves: Int = 0,
        maxSpeed: Double = 0.0,
        avgHeartRate: Double = 0.0,
        distanceSurfed: Double = 0.0,
        distancePaddled: Double = 0.0,
        strokeCount: Int = 0,
        notes: String? = nil,
        isUploaded: Bool = false
    ) -> SurfSessionEntity {
        let context = coreDataManager.viewContext
        let session = SurfSessionEntity(context: context)
        
        session.id = UUID()
        session.startDate = startDate
        session.endDate = endDate
        session.location = location
        session.latitude = latitude
        session.longitude = longitude
        session.totalWaves = Int32(totalWaves)
        session.maxSpeed = maxSpeed
        session.avgHeartRate = avgHeartRate
        session.distanceSurfed = distanceSurfed
        session.distancePaddled = distancePaddled
        session.strokeCount = Int32(strokeCount)
        session.notes = notes
        session.isUploaded = isUploaded
        
        coreDataManager.saveContext()
        return session
    }
    
    public func updateSession(_ session: SurfSessionEntity, with updatedSession: SurfSession) {
        session.startDate = updatedSession.startDate
        session.endDate = updatedSession.endDate
        session.location = updatedSession.location
        session.latitude = updatedSession.latitude
        session.longitude = updatedSession.longitude
        session.totalWaves = Int32(updatedSession.totalWaves)
        session.maxSpeed = updatedSession.maxSpeed
        session.avgHeartRate = updatedSession.avgHeartRate
        session.distanceSurfed = updatedSession.distanceSurfed
        session.distancePaddled = updatedSession.distancePaddled
        session.strokeCount = Int32(updatedSession.strokeCount)
        session.notes = updatedSession.notes
        session.isUploaded = updatedSession.isUploaded
        
        coreDataManager.saveContext()
    }
    
    public func deleteSession(_ session: SurfSessionEntity) {
        let context = coreDataManager.viewContext
        context.delete(session)
        coreDataManager.saveContext()
    }
    
    public func getAllSessions() -> [SurfSessionEntity] {
        return SurfSessionEntity.fetchAll(in: coreDataManager.viewContext)
    }
    
    public func getSession(withId id: UUID) -> SurfSessionEntity? {
        return SurfSessionEntity.fetch(withId: id, in: coreDataManager.viewContext)
    }
    
    // MARK: - Wave Operations
    
    public func addWave(
        toSession session: SurfSessionEntity,
        startTime: Date,
        endTime: Date,
        distance: Double,
        duration: Double,
        maxSpeed: Double,
        coordinates: Data,
        confidence: Double
    ) -> WaveEntity {
        let context = coreDataManager.viewContext
        let wave = WaveEntity(context: context)
        
        wave.id = UUID()
        wave.startTime = startTime
        wave.endTime = endTime
        wave.distance = distance
        wave.duration = duration
        wave.maxSpeed = maxSpeed
        wave.coordinates = coordinates
        wave.confidence = confidence
        wave.session = session
        
        // Update session totalWaves count
        session.totalWaves += 1
        
        // Update session maxSpeed if this wave has a higher speed
        if maxSpeed > session.maxSpeed {
            session.maxSpeed = maxSpeed
        }
        
        coreDataManager.saveContext()
        return wave
    }
    
    public func updateWave(_ wave: WaveEntity, with updatedWave: Wave) {
        wave.startTime = updatedWave.startTime
        wave.endTime = updatedWave.endTime
        wave.distance = updatedWave.distance
        wave.duration = updatedWave.duration
        wave.maxSpeed = updatedWave.maxSpeed
        wave.coordinates = updatedWave.coordinates
        wave.confidence = updatedWave.confidence
        
        coreDataManager.saveContext()
    }
    
    public func deleteWave(_ wave: WaveEntity) {
        if let session = wave.session {
            session.totalWaves -= 1
        }
        
        let context = coreDataManager.viewContext
        context.delete(wave)
        coreDataManager.saveContext()
    }
    
    public func getWavesForSession(withId sessionId: UUID) -> [WaveEntity] {
        return WaveEntity.fetchWaves(forSessionId: sessionId, in: coreDataManager.viewContext)
    }
}

================
File: DuskerKit/Sources/DuskerKit/Utilities/DateUtilities.swift
================
import Foundation

public extension Date {
    func formattedDate() -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: self)
    }
    
    func formattedTime() -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .none
        formatter.timeStyle = .short
        return formatter.string(from: self)
    }
    
    func formattedDay() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE, MMM d"
        return formatter.string(from: self)
    }
    
    static func timeIntervalToString(_ interval: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute, .second]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: interval) ?? "0s"
    }
}

================
File: DuskerKit/Sources/DuskerKit/Utilities/PreviewData.swift
================
import Foundation
import CoreData

public class PreviewData {
    
    // MARK: - Core Data Preview Helper
    
    public static func createPreviewContext() -> NSManagedObjectContext {
        // Create model programmatically for testing
        let managedObjectModel = createManagedObjectModel()
        
        let persistentContainer = NSPersistentContainer(name: "DuskerDataModel", managedObjectModel: managedObjectModel)
        
        // Configure in-memory store
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        persistentContainer.persistentStoreDescriptions = [description]
        
        persistentContainer.loadPersistentStores { (storeDescription, error) in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
        
        let context = persistentContainer.viewContext
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return context
    }
    
    // Create the managed object model programmatically
    private static func createManagedObjectModel() -> NSManagedObjectModel {
        let model = NSManagedObjectModel()
        
        // Create SurfSession entity
        let surfSessionEntity = NSEntityDescription()
        surfSessionEntity.name = "SurfSession"
        surfSessionEntity.managedObjectClassName = "SurfSessionEntity"
        
        // Create Wave entity
        let waveEntity = NSEntityDescription()
        waveEntity.name = "Wave"
        waveEntity.managedObjectClassName = "WaveEntity"
        
        // Create SurfSession attributes
        let idAttribute = NSAttributeDescription()
        idAttribute.name = "id"
        idAttribute.attributeType = .UUIDAttributeType
        idAttribute.isOptional = false
        
        let startDateAttribute = NSAttributeDescription()
        startDateAttribute.name = "startDate"
        startDateAttribute.attributeType = .dateAttributeType
        startDateAttribute.isOptional = false
        
        let endDateAttribute = NSAttributeDescription()
        endDateAttribute.name = "endDate"
        endDateAttribute.attributeType = .dateAttributeType
        endDateAttribute.isOptional = true
        
        let locationAttribute = NSAttributeDescription()
        locationAttribute.name = "location"
        locationAttribute.attributeType = .stringAttributeType
        locationAttribute.isOptional = false
        locationAttribute.defaultValue = ""
        
        let latitudeAttribute = NSAttributeDescription()
        latitudeAttribute.name = "latitude"
        latitudeAttribute.attributeType = .doubleAttributeType
        latitudeAttribute.isOptional = true
        latitudeAttribute.defaultValue = 0.0
        
        let longitudeAttribute = NSAttributeDescription()
        longitudeAttribute.name = "longitude"
        longitudeAttribute.attributeType = .doubleAttributeType
        longitudeAttribute.isOptional = true
        longitudeAttribute.defaultValue = 0.0
        
        let totalWavesAttribute = NSAttributeDescription()
        totalWavesAttribute.name = "totalWaves"
        totalWavesAttribute.attributeType = .integer32AttributeType
        totalWavesAttribute.isOptional = true
        totalWavesAttribute.defaultValue = 0
        
        let maxSpeedAttribute = NSAttributeDescription()
        maxSpeedAttribute.name = "maxSpeed"
        maxSpeedAttribute.attributeType = .doubleAttributeType
        maxSpeedAttribute.isOptional = true
        maxSpeedAttribute.defaultValue = 0.0
        
        let avgHeartRateAttribute = NSAttributeDescription()
        avgHeartRateAttribute.name = "avgHeartRate"
        avgHeartRateAttribute.attributeType = .doubleAttributeType
        avgHeartRateAttribute.isOptional = true
        avgHeartRateAttribute.defaultValue = 0.0
        
        let distanceSurfedAttribute = NSAttributeDescription()
        distanceSurfedAttribute.name = "distanceSurfed"
        distanceSurfedAttribute.attributeType = .doubleAttributeType
        distanceSurfedAttribute.isOptional = true
        distanceSurfedAttribute.defaultValue = 0.0
        
        let distancePaddledAttribute = NSAttributeDescription()
        distancePaddledAttribute.name = "distancePaddled"
        distancePaddledAttribute.attributeType = .doubleAttributeType
        distancePaddledAttribute.isOptional = true
        distancePaddledAttribute.defaultValue = 0.0
        
        let strokeCountAttribute = NSAttributeDescription()
        strokeCountAttribute.name = "strokeCount"
        strokeCountAttribute.attributeType = .integer32AttributeType
        strokeCountAttribute.isOptional = true
        strokeCountAttribute.defaultValue = 0
        
        let notesAttribute = NSAttributeDescription()
        notesAttribute.name = "notes"
        notesAttribute.attributeType = .stringAttributeType
        notesAttribute.isOptional = true
        
        let isUploadedAttribute = NSAttributeDescription()
        isUploadedAttribute.name = "isUploaded"
        isUploadedAttribute.attributeType = .booleanAttributeType
        isUploadedAttribute.isOptional = false
        isUploadedAttribute.defaultValue = false
        
        // Create Wave attributes
        let waveIdAttribute = NSAttributeDescription()
        waveIdAttribute.name = "id"
        waveIdAttribute.attributeType = .UUIDAttributeType
        waveIdAttribute.isOptional = false
        
        let startTimeAttribute = NSAttributeDescription()
        startTimeAttribute.name = "startTime"
        startTimeAttribute.attributeType = .dateAttributeType
        startTimeAttribute.isOptional = false
        
        let endTimeAttribute = NSAttributeDescription()
        endTimeAttribute.name = "endTime"
        endTimeAttribute.attributeType = .dateAttributeType
        endTimeAttribute.isOptional = false
        
        let distanceAttribute = NSAttributeDescription()
        distanceAttribute.name = "distance"
        distanceAttribute.attributeType = .doubleAttributeType
        distanceAttribute.isOptional = true
        distanceAttribute.defaultValue = 0.0
        
        let durationAttribute = NSAttributeDescription()
        durationAttribute.name = "duration"
        durationAttribute.attributeType = .doubleAttributeType
        durationAttribute.isOptional = true
        durationAttribute.defaultValue = 0.0
        
        let waveMaxSpeedAttribute = NSAttributeDescription()
        waveMaxSpeedAttribute.name = "maxSpeed"
        waveMaxSpeedAttribute.attributeType = .doubleAttributeType
        waveMaxSpeedAttribute.isOptional = true
        waveMaxSpeedAttribute.defaultValue = 0.0
        
        let coordinatesAttribute = NSAttributeDescription()
        coordinatesAttribute.name = "coordinates"
        coordinatesAttribute.attributeType = .binaryDataAttributeType
        coordinatesAttribute.isOptional = true
        
        let confidenceAttribute = NSAttributeDescription()
        confidenceAttribute.name = "confidence"
        confidenceAttribute.attributeType = .doubleAttributeType
        confidenceAttribute.isOptional = true
        confidenceAttribute.defaultValue = 0.0
        
        // Add attributes to entities
        surfSessionEntity.properties = [
            idAttribute,
            startDateAttribute,
            endDateAttribute,
            locationAttribute,
            latitudeAttribute,
            longitudeAttribute,
            totalWavesAttribute,
            maxSpeedAttribute,
            avgHeartRateAttribute,
            distanceSurfedAttribute,
            distancePaddledAttribute,
            strokeCountAttribute,
            notesAttribute,
            isUploadedAttribute
        ]
        
        waveEntity.properties = [
            waveIdAttribute,
            startTimeAttribute,
            endTimeAttribute,
            distanceAttribute,
            durationAttribute,
            waveMaxSpeedAttribute,
            coordinatesAttribute,
            confidenceAttribute
        ]
        
        // Create relationships
        let wavesToSessionRelationship = NSRelationshipDescription()
        wavesToSessionRelationship.name = "session"
        wavesToSessionRelationship.destinationEntity = surfSessionEntity
        wavesToSessionRelationship.deleteRule = .nullifyDeleteRule
        wavesToSessionRelationship.maxCount = 1
        wavesToSessionRelationship.minCount = 0
        
        let sessionToWavesRelationship = NSRelationshipDescription()
        sessionToWavesRelationship.name = "waves"
        sessionToWavesRelationship.destinationEntity = waveEntity
        sessionToWavesRelationship.deleteRule = .cascadeDeleteRule
        sessionToWavesRelationship.minCount = 0
        
        // Set inverse relationships
        wavesToSessionRelationship.inverseRelationship = sessionToWavesRelationship
        sessionToWavesRelationship.inverseRelationship = wavesToSessionRelationship
        
        // Add relationships to entities
        surfSessionEntity.properties.append(sessionToWavesRelationship)
        waveEntity.properties.append(wavesToSessionRelationship)
        
        // Add entities to model
        model.entities = [surfSessionEntity, waveEntity]
        
        return model
    }
    
    // MARK: - Sample Data Generation
    
    public static func createSampleData(in context: NSManagedObjectContext) {
        // Create sample sessions
        let session1 = createSampleSession(
            in: context,
            id: UUID(),
            startDate: Date().addingTimeInterval(-3600 * 3), // 3 hours ago
            endDate: Date().addingTimeInterval(-3600), // 1 hour ago
            location: "Malibu Beach",
            latitude: 34.0259,
            longitude: -118.7798,
            totalWaves: 12,
            maxSpeed: 15.7,
            avgHeartRate: 142.5,
            distanceSurfed: 1250.0,
            distancePaddled: 3500.0,
            strokeCount: 1200,
            notes: "Great session with clean waves",
            isUploaded: true
        )
        
        let session2 = createSampleSession(
            in: context,
            id: UUID(),
            startDate: Date().addingTimeInterval(-86400), // 1 day ago
            endDate: Date().addingTimeInterval(-86400 + 7200), // 1 day ago + 2 hours
            location: "Huntington Beach",
            latitude: 33.6595,
            longitude: -118.0010,
            totalWaves: 8,
            maxSpeed: 12.3,
            avgHeartRate: 138.2,
            distanceSurfed: 980.0,
            distancePaddled: 2800.0,
            strokeCount: 950,
            notes: "Crowded but found some good waves",
            isUploaded: true
        )
        
        let session3 = createSampleSession(
            in: context,
            id: UUID(),
            startDate: Date().addingTimeInterval(-172800), // 2 days ago
            endDate: Date().addingTimeInterval(-172800 + 5400), // 2 days ago + 1.5 hours
            location: "Trestles",
            latitude: 33.3853,
            longitude: -117.5939,
            totalWaves: 15,
            maxSpeed: 18.2,
            avgHeartRate: 145.8,
            distanceSurfed: 1800.0,
            distancePaddled: 4200.0,
            strokeCount: 1450,
            notes: "Perfect conditions, best session in weeks",
            isUploaded: false
        )
        
        // Add waves to sessions
        addSampleWaves(to: session1, in: context, count: 12)
        addSampleWaves(to: session2, in: context, count: 8)
        addSampleWaves(to: session3, in: context, count: 15)
        
        // Save the context
        do {
            try context.save()
        } catch {
            print("Error saving preview context: \(error)")
        }
    }
    
    private static func createSampleSession(
        in context: NSManagedObjectContext,
        id: UUID,
        startDate: Date,
        endDate: Date?,
        location: String,
        latitude: Double,
        longitude: Double,
        totalWaves: Int,
        maxSpeed: Double,
        avgHeartRate: Double,
        distanceSurfed: Double,
        distancePaddled: Double,
        strokeCount: Int,
        notes: String?,
        isUploaded: Bool
    ) -> SurfSessionEntity {
        let session = SurfSessionEntity(context: context)
        session.id = id
        session.startDate = startDate
        session.endDate = endDate
        session.location = location
        session.latitude = latitude
        session.longitude = longitude
        session.totalWaves = Int32(totalWaves)
        session.maxSpeed = maxSpeed
        session.avgHeartRate = avgHeartRate
        session.distanceSurfed = distanceSurfed
        session.distancePaddled = distancePaddled
        session.strokeCount = Int32(strokeCount)
        session.notes = notes
        session.isUploaded = isUploaded
        return session
    }
    
    private static func addSampleWaves(to session: SurfSessionEntity, in context: NSManagedObjectContext, count: Int) {
        guard let sessionEndDate = session.endDate else { return }
        let sessionDuration = sessionEndDate.timeIntervalSince(session.startDate)
        let averageWaveDuration: TimeInterval = 30 // 30 seconds per wave
        
        for i in 0..<count {
            // Distribute waves evenly throughout the session
            let waveStartOffset = (sessionDuration / Double(count + 1)) * Double(i + 1)
            let waveStartTime = session.startDate.addingTimeInterval(waveStartOffset)
            let waveEndTime = waveStartTime.addingTimeInterval(averageWaveDuration)
            
            // Create random wave data
            let distance = Double.random(in: 50...200)
            let duration = waveEndTime.timeIntervalSince(waveStartTime)
            let maxSpeed = Double.random(in: 8...20)
            
            // Create sample coordinates data
            let coordinates = createSampleCoordinates(
                startLat: session.latitude,
                startLon: session.longitude,
                distance: distance
            )
            
            // Create the wave
            let wave = WaveEntity(context: context)
            wave.id = UUID()
            wave.startTime = waveStartTime
            wave.endTime = waveEndTime
            wave.distance = distance
            wave.duration = duration
            wave.maxSpeed = maxSpeed
            wave.coordinates = coordinates
            wave.confidence = Double.random(in: 0.7...1.0)
            wave.session = session
        }
    }
    
    private static func createSampleCoordinates(startLat: Double, startLon: Double, distance: Double) -> Data {
        // Create a simple array of coordinates that simulate a wave ride
        // In a real app, this would be actual GPS coordinates
        var coordinates: [[String: Double]] = []
        
        // Number of points to generate
        let pointCount = 20
        
        // Small random variations to simulate movement
        for i in 0..<pointCount {
            let progress = Double(i) / Double(pointCount - 1)
            let latOffset = (distance / 111000.0) * progress * Double.random(in: 0.8...1.2) // Convert meters to degrees
            let lonOffset = (distance / 111000.0) * progress * Double.random(in: 0.8...1.2) / cos(startLat * .pi / 180.0)
            
            let point: [String: Double] = [
                "latitude": startLat + latOffset * Double.random(in: -1...1),
                "longitude": startLon + lonOffset * Double.random(in: -1...1),
                "timestamp": Double(i) // Simplified timestamp
            ]
            coordinates.append(point)
        }
        
        // Convert to Data
        do {
            return try JSONSerialization.data(withJSONObject: coordinates, options: [])
        } catch {
            print("Error creating sample coordinates: \(error)")
            return Data()
        }
    }
}

================
File: DuskerKit/Tests/DuskerKitTests/CoreDataTests.swift
================
import XCTest
import CoreData
@testable import DuskerKit

final class CoreDataTests: XCTestCase {
    
    var context: NSManagedObjectContext!
    
    override func setUp() {
        super.setUp()
        context = createInMemoryContext()
    }
    
    override func tearDown() {
        context = nil
        super.tearDown()
    }
    
    // Create an in-memory Core Data stack for testing
    private func createInMemoryContext() -> NSManagedObjectContext {
        let model = createTestModel()
        let container = NSPersistentContainer(name: "TestModel", managedObjectModel: model)
        
        let description = NSPersistentStoreDescription()
        description.type = NSInMemoryStoreType
        container.persistentStoreDescriptions = [description]
        
        container.loadPersistentStores { (_, error) in
            if let error = error as NSError? {
                fatalError("Failed to load stores: \(error), \(error.userInfo)")
            }
        }
        
        return container.viewContext
    }
    
    // Create a test model programmatically
    private func createTestModel() -> NSManagedObjectModel {
        let model = NSManagedObjectModel()
        
        // Create SurfSession entity
        let surfSessionEntity = NSEntityDescription()
        surfSessionEntity.name = "SurfSession"
        surfSessionEntity.managedObjectClassName = NSStringFromClass(SurfSessionEntity.self)
        
        // Create Wave entity
        let waveEntity = NSEntityDescription()
        waveEntity.name = "Wave"
        waveEntity.managedObjectClassName = NSStringFromClass(WaveEntity.self)
        
        // Create SurfSession attributes
        let idAttribute = NSAttributeDescription()
        idAttribute.name = "id"
        idAttribute.attributeType = .UUIDAttributeType
        idAttribute.isOptional = false
        
        let startDateAttribute = NSAttributeDescription()
        startDateAttribute.name = "startDate"
        startDateAttribute.attributeType = .dateAttributeType
        startDateAttribute.isOptional = false
        
        let endDateAttribute = NSAttributeDescription()
        endDateAttribute.name = "endDate"
        endDateAttribute.attributeType = .dateAttributeType
        endDateAttribute.isOptional = true
        
        let locationAttribute = NSAttributeDescription()
        locationAttribute.name = "location"
        locationAttribute.attributeType = .stringAttributeType
        locationAttribute.isOptional = false
        locationAttribute.defaultValue = ""
        
        let latitudeAttribute = NSAttributeDescription()
        latitudeAttribute.name = "latitude"
        latitudeAttribute.attributeType = .doubleAttributeType
        latitudeAttribute.isOptional = true
        latitudeAttribute.defaultValue = 0.0
        
        let longitudeAttribute = NSAttributeDescription()
        longitudeAttribute.name = "longitude"
        longitudeAttribute.attributeType = .doubleAttributeType
        longitudeAttribute.isOptional = true
        longitudeAttribute.defaultValue = 0.0
        
        let totalWavesAttribute = NSAttributeDescription()
        totalWavesAttribute.name = "totalWaves"
        totalWavesAttribute.attributeType = .integer32AttributeType
        totalWavesAttribute.isOptional = true
        totalWavesAttribute.defaultValue = 0
        
        let maxSpeedAttribute = NSAttributeDescription()
        maxSpeedAttribute.name = "maxSpeed"
        maxSpeedAttribute.attributeType = .doubleAttributeType
        maxSpeedAttribute.isOptional = true
        maxSpeedAttribute.defaultValue = 0.0
        
        let avgHeartRateAttribute = NSAttributeDescription()
        avgHeartRateAttribute.name = "avgHeartRate"
        avgHeartRateAttribute.attributeType = .doubleAttributeType
        avgHeartRateAttribute.isOptional = true
        avgHeartRateAttribute.defaultValue = 0.0
        
        let distanceSurfedAttribute = NSAttributeDescription()
        distanceSurfedAttribute.name = "distanceSurfed"
        distanceSurfedAttribute.attributeType = .doubleAttributeType
        distanceSurfedAttribute.isOptional = true
        distanceSurfedAttribute.defaultValue = 0.0
        
        let distancePaddledAttribute = NSAttributeDescription()
        distancePaddledAttribute.name = "distancePaddled"
        distancePaddledAttribute.attributeType = .doubleAttributeType
        distancePaddledAttribute.isOptional = true
        distancePaddledAttribute.defaultValue = 0.0
        
        let strokeCountAttribute = NSAttributeDescription()
        strokeCountAttribute.name = "strokeCount"
        strokeCountAttribute.attributeType = .integer32AttributeType
        strokeCountAttribute.isOptional = true
        strokeCountAttribute.defaultValue = 0
        
        let notesAttribute = NSAttributeDescription()
        notesAttribute.name = "notes"
        notesAttribute.attributeType = .stringAttributeType
        notesAttribute.isOptional = true
        
        let isUploadedAttribute = NSAttributeDescription()
        isUploadedAttribute.name = "isUploaded"
        isUploadedAttribute.attributeType = .booleanAttributeType
        isUploadedAttribute.isOptional = false
        isUploadedAttribute.defaultValue = false
        
        // Create Wave attributes
        let waveIdAttribute = NSAttributeDescription()
        waveIdAttribute.name = "id"
        waveIdAttribute.attributeType = .UUIDAttributeType
        waveIdAttribute.isOptional = false
        
        let startTimeAttribute = NSAttributeDescription()
        startTimeAttribute.name = "startTime"
        startTimeAttribute.attributeType = .dateAttributeType
        startTimeAttribute.isOptional = false
        
        let endTimeAttribute = NSAttributeDescription()
        endTimeAttribute.name = "endTime"
        endTimeAttribute.attributeType = .dateAttributeType
        endTimeAttribute.isOptional = false
        
        let distanceAttribute = NSAttributeDescription()
        distanceAttribute.name = "distance"
        distanceAttribute.attributeType = .doubleAttributeType
        distanceAttribute.isOptional = true
        distanceAttribute.defaultValue = 0.0
        
        let durationAttribute = NSAttributeDescription()
        durationAttribute.name = "duration"
        durationAttribute.attributeType = .doubleAttributeType
        durationAttribute.isOptional = true
        durationAttribute.defaultValue = 0.0
        
        let waveMaxSpeedAttribute = NSAttributeDescription()
        waveMaxSpeedAttribute.name = "maxSpeed"
        waveMaxSpeedAttribute.attributeType = .doubleAttributeType
        waveMaxSpeedAttribute.isOptional = true
        waveMaxSpeedAttribute.defaultValue = 0.0
        
        let coordinatesAttribute = NSAttributeDescription()
        coordinatesAttribute.name = "coordinates"
        coordinatesAttribute.attributeType = .binaryDataAttributeType
        coordinatesAttribute.isOptional = true
        
        let confidenceAttribute = NSAttributeDescription()
        confidenceAttribute.name = "confidence"
        confidenceAttribute.attributeType = .doubleAttributeType
        confidenceAttribute.isOptional = true
        confidenceAttribute.defaultValue = 0.0
        
        // Add attributes to entities
        surfSessionEntity.properties = [
            idAttribute,
            startDateAttribute,
            endDateAttribute,
            locationAttribute,
            latitudeAttribute,
            longitudeAttribute,
            totalWavesAttribute,
            maxSpeedAttribute,
            avgHeartRateAttribute,
            distanceSurfedAttribute,
            distancePaddledAttribute,
            strokeCountAttribute,
            notesAttribute,
            isUploadedAttribute
        ]
        
        waveEntity.properties = [
            waveIdAttribute,
            startTimeAttribute,
            endTimeAttribute,
            distanceAttribute,
            durationAttribute,
            waveMaxSpeedAttribute,
            coordinatesAttribute,
            confidenceAttribute
        ]
        
        // Create relationships
        let wavesToSessionRelationship = NSRelationshipDescription()
        wavesToSessionRelationship.name = "session"
        wavesToSessionRelationship.destinationEntity = surfSessionEntity
        wavesToSessionRelationship.deleteRule = .nullifyDeleteRule
        wavesToSessionRelationship.maxCount = 1
        wavesToSessionRelationship.minCount = 0
        
        let sessionToWavesRelationship = NSRelationshipDescription()
        sessionToWavesRelationship.name = "waves"
        sessionToWavesRelationship.destinationEntity = waveEntity
        sessionToWavesRelationship.deleteRule = .cascadeDeleteRule
        sessionToWavesRelationship.minCount = 0
        
        // Set inverse relationships
        wavesToSessionRelationship.inverseRelationship = sessionToWavesRelationship
        sessionToWavesRelationship.inverseRelationship = wavesToSessionRelationship
        
        // Add relationships to entities
        surfSessionEntity.properties.append(sessionToWavesRelationship)
        waveEntity.properties.append(wavesToSessionRelationship)
        
        // Add entities to model
        model.entities = [surfSessionEntity, waveEntity]
        
        return model
    }
    
    // MARK: - Test Session Creation and Saving
    
    func testCreateAndSaveSurfSession() {
        // Create a new session
        let session = NSEntityDescription.insertNewObject(forEntityName: "SurfSession", into: context) as! SurfSessionEntity
        session.id = UUID()
        session.startDate = Date()
        session.location = "Test Beach"
        session.latitude = 34.0259
        session.longitude = -118.7798
        session.totalWaves = 5
        session.maxSpeed = 12.5
        session.avgHeartRate = 140.0
        session.distanceSurfed = 800.0
        session.distancePaddled = 2000.0
        session.strokeCount = 750
        session.isUploaded = false
        
        // Save the context
        XCTAssertNoThrow(try context.save(), "Should save context without throwing")
        
        // Fetch the session
        let fetchRequest = NSFetchRequest<SurfSessionEntity>(entityName: "SurfSession")
        fetchRequest.predicate = NSPredicate(format: "id == %@", session.id as CVarArg)
        
        do {
            let results = try context.fetch(fetchRequest)
            XCTAssertEqual(results.count, 1, "Should fetch exactly one session")
            
            let fetchedSession = results.first!
            XCTAssertEqual(fetchedSession.id, session.id)
            XCTAssertEqual(fetchedSession.location, "Test Beach")
            XCTAssertEqual(fetchedSession.totalWaves, 5)
            XCTAssertEqual(fetchedSession.maxSpeed, 12.5)
        } catch {
            XCTFail("Failed to fetch session: \(error)")
        }
    }
    
    // MARK: - Test Adding Waves to Session
    
    func testAddWavesToSession() {
        // Create a session
        let session = NSEntityDescription.insertNewObject(forEntityName: "SurfSession", into: context) as! SurfSessionEntity
        session.id = UUID()
        session.startDate = Date()
        session.location = "Wave Test Beach"
        session.totalWaves = 0
        
        // Add waves to the session
        for i in 1...3 {
            let wave = NSEntityDescription.insertNewObject(forEntityName: "Wave", into: context) as! WaveEntity
            wave.id = UUID()
            wave.startTime = Date().addingTimeInterval(Double(i) * 300)
            wave.endTime = Date().addingTimeInterval(Double(i) * 300 + 30)
            wave.distance = Double(i) * 100
            wave.duration = 30.0
            wave.maxSpeed = Double(i) * 5
            wave.coordinates = Data()
            wave.confidence = 0.9
            wave.session = session
            
            // Update session totalWaves
            session.totalWaves += 1
        }
        
        // Save the context
        XCTAssertNoThrow(try context.save(), "Should save context without throwing")
        
        // Fetch the session with waves
        let fetchRequest = NSFetchRequest<SurfSessionEntity>(entityName: "SurfSession")
        fetchRequest.predicate = NSPredicate(format: "id == %@", session.id as CVarArg)
        
        do {
            let results = try context.fetch(fetchRequest)
            XCTAssertEqual(results.count, 1, "Should fetch exactly one session")
            
            let fetchedSession = results.first!
            XCTAssertEqual(fetchedSession.totalWaves, 3, "Session should have 3 waves")
            XCTAssertEqual(fetchedSession.waves?.count, 3, "Session waves relationship should contain 3 waves")
            
            // Test the waves array computed property
            XCTAssertEqual(fetchedSession.wavesArray.count, 3, "wavesArray should return 3 waves")
            
            // Verify waves are sorted by startTime
            let sortedWaves = fetchedSession.wavesArray
            for i in 0..<sortedWaves.count-1 {
                XCTAssertLessThanOrEqual(sortedWaves[i].startTime, sortedWaves[i+1].startTime, "Waves should be sorted by startTime")
            }
        } catch {
            XCTFail("Failed to fetch session with waves: \(error)")
        }
    }
    
    // MARK: - Test Fetching Sessions with Waves
    
    func testFetchSessionsWithWaves() {
        // Create sample sessions
        for i in 1...3 {
            let session = NSEntityDescription.insertNewObject(forEntityName: "SurfSession", into: context) as! SurfSessionEntity
            session.id = UUID()
            session.startDate = Date().addingTimeInterval(-Double(i) * 86400) // i days ago
            session.endDate = Date().addingTimeInterval(-Double(i) * 86400 + 7200) // i days ago + 2 hours
            session.location = "Beach \(i)"
            session.totalWaves = Int32(i * 5) // 5, 10, 15 waves
            
            // Add waves to the session
            for j in 1...Int(session.totalWaves) {
                let wave = NSEntityDescription.insertNewObject(forEntityName: "Wave", into: context) as! WaveEntity
                wave.id = UUID()
                wave.startTime = session.startDate.addingTimeInterval(Double(j) * 300)
                wave.endTime = wave.startTime.addingTimeInterval(30)
                wave.session = session
            }
        }
        
        // Save the context
        XCTAssertNoThrow(try context.save(), "Should save context without throwing")
        
        // Fetch all sessions
        let fetchRequest = NSFetchRequest<SurfSessionEntity>(entityName: "SurfSession")
        fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \SurfSessionEntity.startDate, ascending: false)]
        
        do {
            let sessions = try context.fetch(fetchRequest)
            XCTAssertEqual(sessions.count, 3, "Should fetch 3 sample sessions")
            
            // Check each session has the correct number of waves
            XCTAssertEqual(sessions[0].totalWaves, 5, "Session 1 should have 5 waves")
            XCTAssertEqual(sessions[1].totalWaves, 10, "Session 2 should have 10 waves")
            XCTAssertEqual(sessions[2].totalWaves, 15, "Session 3 should have 15 waves")
            
            // Check waves relationship
            XCTAssertEqual(sessions[0].waves?.count, 5, "Session 1 should have 5 waves in relationship")
            XCTAssertEqual(sessions[1].waves?.count, 10, "Session 2 should have 10 waves in relationship")
            XCTAssertEqual(sessions[2].waves?.count, 15, "Session 3 should have 15 waves in relationship")
        } catch {
            XCTFail("Failed to fetch sessions with waves: \(error)")
        }
    }
    
    // MARK: - Test Deleting Session and Cascade Delete Waves
    
    func testDeleteSessionCascadeDeleteWaves() {
        // Create a session with waves
        let session = NSEntityDescription.insertNewObject(forEntityName: "SurfSession", into: context) as! SurfSessionEntity
        session.id = UUID()
        session.startDate = Date()
        session.location = "Delete Test Beach"
        
        // Add waves to the session
        var waveIds: [UUID] = []
        for _ in 1...5 {
            let wave = NSEntityDescription.insertNewObject(forEntityName: "Wave", into: context) as! WaveEntity
            let waveId = UUID()
            wave.id = waveId
            wave.startTime = Date()
            wave.endTime = Date().addingTimeInterval(30)
            wave.session = session
            waveIds.append(waveId)
        }
        
        // Save the context
        do {
            try context.save()
        } catch {
            XCTFail("Failed to save context: \(error)")
            return
        }
        
        // Verify waves were created
        let initialWaveFetchRequest = NSFetchRequest<WaveEntity>(entityName: "Wave")
        do {
            let initialWaves = try context.fetch(initialWaveFetchRequest)
            XCTAssertEqual(initialWaves.count, 5, "Should have 5 waves before deletion")
        } catch {
            XCTFail("Failed to fetch initial waves: \(error)")
            return
        }
        
        // Delete the session
        context.delete(session)
        
        // Save the context after deletion
        do {
            try context.save()
        } catch {
            XCTFail("Failed to save context after deletion: \(error)")
            return
        }
        
        // Verify session is deleted
        let sessionFetchRequest = NSFetchRequest<SurfSessionEntity>(entityName: "SurfSession")
        do {
            let sessionResults = try context.fetch(sessionFetchRequest)
            XCTAssertEqual(sessionResults.count, 0, "Session should be deleted")
        } catch {
            XCTFail("Failed to verify session deletion: \(error)")
            return
        }
        
        // Verify waves are deleted (cascade delete)
        let waveFetchRequest = NSFetchRequest<WaveEntity>(entityName: "Wave")
        do {
            let waveResults = try context.fetch(waveFetchRequest)
            XCTAssertEqual(waveResults.count, 0, "All waves should be deleted with cascade delete")
        } catch {
            XCTFail("Failed to verify wave deletion: \(error)")
        }
    }
}

================
File: DuskerKit/Tests/DuskerKitTests/DuskerKitTests.swift
================
import XCTest
@testable import DuskerKit

final class DuskerKitTests: XCTestCase {
    func testSurfSessionInitialization() {
        let session = SurfSession()
        XCTAssertNotNil(session.id)
        XCTAssertNil(session.endDate)
        XCTAssertEqual(session.totalWaves, 0)
    }
    
    func testWaveInitialization() {
        let wave = Wave()
        XCTAssertNotNil(wave.id)
        XCTAssertEqual(wave.confidence, 1.0)
    }
    
    func testDateUtilities() {
        let date = Date()
        XCTAssertFalse(date.formattedDate().isEmpty)
        XCTAssertFalse(date.formattedTime().isEmpty)
        XCTAssertFalse(date.formattedDay().isEmpty)
    }
}

================
File: DuskerKit/Package.swift
================
// swift-tools-version:5.7
import PackageDescription

let package = Package(
    name: "DuskerKit",
    platforms: [
        .iOS(.v16),
        .watchOS(.v9),
        .macOS(.v12)
    ],
    products: [
        .library(
            name: "DuskerKit",
            targets: ["DuskerKit"]),
    ],
    dependencies: [
        // Dependencies go here
    ],
    targets: [
        .target(
            name: "DuskerKit",
            dependencies: [],
            path: "Sources/DuskerKit",
            resources: [
                .process("Models/DuskerDataModel.xcdatamodeld"),
                .process("Models/README.md")
            ]),
        .testTarget(
            name: "DuskerKitTests",
            dependencies: ["DuskerKit"]),
    ]
)

================
File: fastlane/Appfile
================
app_identifier("com.dusker.ios") # The bundle identifier of your app
# apple_id("[[APPLE_ID]]") # Your Apple Developer Portal username
# team_id("[[DEV_PORTAL_TEAM_ID]]") # Developer Portal Team ID

# For more information about the Appfile, see:
#     https://docs.fastlane.tools/advanced/#appfile

================
File: fastlane/Fastfile
================
default_platform(:ios)

# Define supported simulators - these are the only ones we support
IOS_SIMULATOR = "platform=iOS Simulator,name=iPhone 14,OS=16.0"
WATCHOS_SIMULATOR = "platform=watchOS Simulator,name=Apple Watch Series 9 (45mm),OS=10.0"

# Get absolute path to the project
PROJECT_PATH = File.expand_path("../Dusker.xcodeproj", __dir__)

platform :ios do
  desc "Run all tests"
  lane :test_all do
    test_ios
    test_watchos
    test_kit
  end

  desc "Run iOS tests"
  lane :test_ios do
    sh("xcodebuild test -project '#{PROJECT_PATH}' -scheme Dusker -destination '#{IOS_SIMULATOR}' | bundle exec xcpretty")
  end

  desc "Run watchOS tests"
  lane :test_watchos do
    sh("xcodebuild test -project '#{PROJECT_PATH}' -scheme DuskerWatch -destination '#{WATCHOS_SIMULATOR}' | bundle exec xcpretty")
  end

  desc "Run DuskerKit tests"
  lane :test_kit do
    sh("cd ../DuskerKit && swift test")
  end
end

================
File: iOS/Views/ContentView.swift
================
import SwiftUI
import DuskerKit

struct ContentView: View {
    var body: some View {
        TabView {
            Text("Sessions")
                .tabItem {
                    Label("Sessions", systemImage: "list.bullet")
                }
            
            Text("Stats")
                .tabItem {
                    Label("Stats", systemImage: "chart.bar")
                }
            
            Text("Settings")
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
        }
        .accentColor(Color("AccentColor"))
        .preferredColorScheme(.dark)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

================
File: iOS/DuskerApp.swift
================
import SwiftUI

@main
struct DuskerApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

================
File: iOS/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Dusker</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>NSHealthShareUsageDescription</key>
	<string>Dusker needs access to your health data to track heart rate during surf sessions.</string>
	<key>NSHealthUpdateUsageDescription</key>
	<string>Dusker needs to save workout data to your Health app.</string>
	<key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
	<string>Dusker needs your location to track your surf sessions even when the app is in the background.</string>
	<key>NSLocationWhenInUseUsageDescription</key>
	<string>Dusker needs your location to track your surf sessions.</string>
	<key>NSMotionUsageDescription</key>
	<string>Dusker needs access to motion data to detect waves and track your surfing activity.</string>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
	</dict>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
</dict>
</plist>

================
File: iOS/LaunchScreen.storyboard
================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21507" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina6_12" orientation="portrait" appearance="light"/>
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21505"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Dusker" textAlignment="natural" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="Ygc-Ry-Pcg">
                                <rect key="frame" x="142.66666666666666" y="408.66666666666669" width="108" height="35"/>
                                <fontDescription key="fontDescription" type="boldSystem" pointSize="29"/>
                                <color key="textColor" white="1" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                                <nil key="highlightedColor"/>
                            </label>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                        <color key="backgroundColor" red="0.039215686274509803" green="0.10196078431372549" blue="0.16470588235294117" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="Ygc-Ry-Pcg" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="Aqf-Oc-Ixf"/>
                            <constraint firstItem="Ygc-Ry-Pcg" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="Qqf-Oc-Ixf"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>

================
File: Shared/Resources/Assets.xcassets/AccentColor.colorset/Contents.json
================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x45",
          "green" : "0x9B",
          "red" : "0xF8"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Shared/Resources/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "idiom" : "watch",
      "role" : "notificationCenter",
      "scale" : "2x",
      "size" : "24x24",
      "subtype" : "38mm"
    },
    {
      "idiom" : "watch",
      "role" : "notificationCenter",
      "scale" : "2x",
      "size" : "27.5x27.5",
      "subtype" : "42mm"
    },
    {
      "idiom" : "watch",
      "role" : "companionSettings",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "watch",
      "role" : "companionSettings",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "40x40",
      "subtype" : "38mm"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "44x44",
      "subtype" : "40mm"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "50x50",
      "subtype" : "44mm"
    },
    {
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "86x86",
      "subtype" : "38mm"
    },
    {
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "98x98",
      "subtype" : "42mm"
    },
    {
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "108x108",
      "subtype" : "44mm"
    },
    {
      "idiom" : "watch-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Shared/Resources/Assets.xcassets/PrimaryBackground.colorset/Contents.json
================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x2A",
          "green" : "0x1A",
          "red" : "0x0A"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Shared/Resources/Assets.xcassets/TextDark.colorset/Contents.json
================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x22",
          "green" : "0x22",
          "red" : "0x22"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Shared/Resources/Assets.xcassets/TextLight.colorset/Contents.json
================
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xFF",
          "green" : "0xFF",
          "red" : "0xFF"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Shared/Resources/Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Tests/iOS/DuskerTests.swift
================
import XCTest
@testable import Dusker

class DuskerTests: XCTestCase {
    
    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testAppBuilds() throws {
        // This is a simple test to verify the app builds correctly
        XCTAssertTrue(true, "App should build successfully")
    }
    
    func testPerformanceExample() throws {
        // This is an example of a performance test case.
        measure {
            // Put the code you want to measure the time of here.
        }
    }
}

================
File: Tests/watchOS/DuskerWatchTests.swift
================
import XCTest
@testable import DuskerWatchExtension

class DuskerWatchTests: XCTestCase {
    
    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }
    
    func testAppBuilds() throws {
        // This is a simple test to verify the app builds correctly
        XCTAssertTrue(true, "Watch app should build successfully")
    }
    
    func testPerformanceExample() throws {
        // This is an example of a performance test case.
        measure {
            // Put the code you want to measure the time of here.
        }
    }
}

================
File: watchOS/Views/ContentView.swift
================
import SwiftUI
import DuskerKit

struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Button(action: {
                    // Start session action
                }) {
                    Text("Start Session")
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .background(Color("AccentColor"))
                        .cornerRadius(10)
                }
                
                NavigationLink(destination: Text("History View")) {
                    Text("History")
                        .font(.body)
                        .foregroundColor(.white)
                }
                
                NavigationLink(destination: Text("Settings View")) {
                    Text("Settings")
                        .font(.body)
                        .foregroundColor(.white)
                }
            }
            .navigationTitle("Dusker")
        }
        .accentColor(Color("AccentColor"))
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

================
File: watchOS/DuskerApp.swift
================
import SwiftUI

@main
struct DuskerApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

================
File: watchOS/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Dusker</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>NSExtension</key>
	<dict>
		<key>NSExtensionAttributes</key>
		<dict>
			<key>WKAppBundleIdentifier</key>
			<string>com.dusker.ios.watchkitapp</string>
		</dict>
		<key>NSExtensionPointIdentifier</key>
		<string>com.apple.watchkit</string>
	</dict>
	<key>NSHealthShareUsageDescription</key>
	<string>Dusker needs access to your health data to track heart rate during surf sessions.</string>
	<key>NSHealthUpdateUsageDescription</key>
	<string>Dusker needs to save workout data to your Health app.</string>
	<key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
	<string>Dusker needs your location to track your surf sessions even when the app is in the background.</string>
	<key>NSLocationWhenInUseUsageDescription</key>
	<string>Dusker needs your location to track your surf sessions.</string>
	<key>NSMotionUsageDescription</key>
	<string>Dusker needs access to motion data to detect waves and track your surfing activity.</string>
	<key>WKBackgroundModes</key>
	<array>
		<string>workout-processing</string>
		<string>location</string>
	</array>
</dict>
</plist>

================
File: .gitignore
================
# Xcode
## User settings
xcuserdata/
*.xcuserstate

## Obj-C/Swift specific
*.hmap
*.ipa
*.dSYM.zip
*.dSYM

## App packaging
*.app
*.pkg
*.dmg

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
.build/
.swiftpm/
Package.resolved
.netrc

# CocoaPods
Pods/
Podfile.lock

# Carthage
Carthage/Build/
Carthage/Checkouts

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output
fastlane/README.md

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# iOS
## Various settings
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Other
*.moved-aside
*.xccheckout
*.xcscmblueprint
.idea/

# watchOS specific
*.watchkit/
*.watchkitextension/
*.appex/

# App thinning
*.xcarchive
*.ipa.metadata.plist

# Debug logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Code coverage
coverage/
*.lcov
.nyc_output

# Generated files
DerivedData/
*.generated.swift

# Build products
build/
dist/

# Created by https://www.toptal.com/developers/gitignore/api/xcode,swift,macos,ios,watchos
# Edit at https://www.toptal.com/developers/gitignore?templates=xcode,swift,macos,ios,watchos

#!! ERROR: ios is undefined. Use list command to see defined gitignore types !!#

### macOS ###
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon

# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

### macOS Patch ###
# iCloud generated files
*.icloud

### Swift ###
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
# Pods/
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
# After new code Injection tools there's a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/

#!! ERROR: watchos is undefined. Use list command to see defined gitignore types !!#

### Xcode ###

## Xcode 8 and earlier

### Xcode Patch ###
*.xcodeproj/*
!*.xcodeproj/project.pbxproj
!*.xcodeproj/xcshareddata/
!*.xcodeproj/project.xcworkspace/
!*.xcworkspace/contents.xcworkspacedata
/*.gcno
**/xcshareddata/WorkspaceSettings.xcsettings

# End of https://www.toptal.com/developers/gitignore/api/xcode,swift,macos,ios,watchos

### Ruby ###
*.gem
*.rbc
/.config
/coverage/
/InstalledFiles
/pkg/
/spec/reports/
/spec/examples.txt
/test/tmp/
/test/version_tmp/
/tmp/

# Used by dotenv library to load environment variables
.env
.env.*

# Ignore Byebug command history file
.byebug_history

## Documentation cache and generated files:
/.yardoc/
/_yardoc/
/doc/
/rdoc/

## Environment normalization:
/.bundle/
/vendor/bundle
/lib/bundler/man/

# for a library or gem, you might want to ignore these files since the code is
# intended to run in multiple environments; otherwise, check them in:
# Gemfile.lock
# .ruby-version
# .ruby-gemset

# unless supporting rvm < 1.11.0 or doing something fancy, ignore this:
.rvmrc
.rvm/

# Used by RuboCop. Remote config files pulled in from inherit_from directive.
.rubocop-https?--*

# rbenv
.rbenv-vars

# End of Ruby-specific patterns

================
File: .ruby-version
================
3.2.2

================
File: .xcode-version
================


================
File: blueprint.md
================
# Blueprint for Surf Tracking Apple Watch App Development

================
File: Gemfile
================
source "https://rubygems.org"

gem "fastlane", "~> 2.219.0"
gem "xcpretty"
gem "abbrev" # Required for Ruby 3.2+
gem "logger" # Required for Ruby 3.2+

================
File: project.yml
================
name: Dusker
options:
  bundleIdPrefix: com.dusker
  deploymentTarget:
    iOS: 16.0
    watchOS: 9.0
  xcodeVersion: "14.0"
  groupSortPosition: top
  generateEmptyDirectories: true

packages:
  DuskerKit:
    path: ./DuskerKit

targets:
  Dusker:
    type: application
    platform: iOS
    sources:
      - iOS
      - Shared
    dependencies:
      - package: DuskerKit
    info:
      path: iOS/Info.plist
      properties:
        CFBundleDisplayName: Dusker
        UILaunchStoryboardName: LaunchScreen
        UIApplicationSceneManifest:
          UIApplicationSupportsMultipleScenes: false
        NSLocationWhenInUseUsageDescription: Dusker needs your location to track your surf sessions.
        NSLocationAlwaysAndWhenInUseUsageDescription: Dusker needs your location to track your surf sessions even when the app is in the background.
        NSHealthShareUsageDescription: Dusker needs access to your health data to track heart rate during surf sessions.
        NSHealthUpdateUsageDescription: Dusker needs to save workout data to your Health app.
        NSMotionUsageDescription: Dusker needs access to motion data to detect waves and track your surfing activity.
    settings:
      base:
        TARGETED_DEVICE_FAMILY: 1,2
        DEVELOPMENT_TEAM: ""
        CODE_SIGN_STYLE: Automatic
        PRODUCT_BUNDLE_IDENTIFIER: com.dusker.ios

  DuskerWatch:
    type: application.watchapp2
    platform: watchOS
    sources:
      - path: watchOS
        excludes:
          - "**/*.swift" # Exclude Swift files from the app target
    dependencies:
      - target: DuskerWatchExtension
    info:
      path: watchOS/Info.plist
      properties:
        CFBundleDisplayName: Dusker
        WKCompanionAppBundleIdentifier: com.dusker.ios
    settings:
      base:
        TARGETED_DEVICE_FAMILY: 4
        DEVELOPMENT_TEAM: ""
        CODE_SIGN_STYLE: Automatic
        PRODUCT_BUNDLE_IDENTIFIER: com.dusker.ios.watchkitapp
        PRODUCT_NAME: DuskerWatch
        SKIP_INSTALL: NO
        ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES: YES

  DuskerWatchExtension:
    type: watchkit2-extension
    platform: watchOS
    sources:
      - watchOS
      - Shared
    dependencies:
      - package: DuskerKit
    info:
      path: watchOS/Info.plist
      properties:
        CFBundleDisplayName: Dusker
        NSExtension:
          NSExtensionAttributes:
            WKAppBundleIdentifier: com.dusker.ios.watchkitapp
          NSExtensionPointIdentifier: com.apple.watchkit
        NSLocationWhenInUseUsageDescription: Dusker needs your location to track your surf sessions.
        NSLocationAlwaysAndWhenInUseUsageDescription: Dusker needs your location to track your surf sessions even when the app is in the background.
        NSHealthShareUsageDescription: Dusker needs access to your health data to track heart rate during surf sessions.
        NSHealthUpdateUsageDescription: Dusker needs to save workout data to your Health app.
        NSMotionUsageDescription: Dusker needs access to motion data to detect waves and track your surfing activity.
        WKBackgroundModes:
          - workout-processing
          - location
    settings:
      base:
        DEVELOPMENT_TEAM: ""
        CODE_SIGN_STYLE: Automatic
        PRODUCT_BUNDLE_IDENTIFIER: com.dusker.ios.watchkitapp.watchkitextension
        PRODUCT_NAME: DuskerWatchExtension
        SKIP_INSTALL: YES

  DuskerTests:
    type: bundle.unit-test
    platform: iOS
    sources:
      - Tests/iOS
    dependencies:
      - target: Dusker
    settings:
      base:
        DEVELOPMENT_TEAM: ""
        CODE_SIGN_STYLE: Automatic
        PRODUCT_BUNDLE_IDENTIFIER: com.dusker.ios.tests
        GENERATE_INFOPLIST_FILE: YES

  DuskerWatchTests:
    type: bundle.unit-test
    platform: watchOS
    sources:
      - Tests/watchOS
    dependencies:
      - target: DuskerWatchExtension
    settings:
      base:
        DEVELOPMENT_TEAM: ""
        CODE_SIGN_STYLE: Automatic
        PRODUCT_BUNDLE_IDENTIFIER: com.dusker.ios.watchkitapp.watchkitextension.tests
        GENERATE_INFOPLIST_FILE: YES

schemes:
  Dusker:
    build:
      targets:
        Dusker: all
    run:
      config: Debug
    test:
      config: Debug
      targets:
        - DuskerTests
    profile:
      config: Release
    analyze:
      config: Debug
    archive:
      config: Release

  DuskerWatch:
    build:
      targets:
        DuskerWatch: all
    run:
      config: Debug
    test:
      config: Debug
      targets:
        - DuskerWatchTests
    profile:
      config: Release
    analyze:
      config: Debug
    archive:
      config: Release

================
File: prompt_plan.md
================
# Prompt Plan

# Table of Contents

## Project Setup and Foundation
1. [Project Setup](#prompt-1-project-setup)
2. [Core Data Models](#prompt-2-core-data-models)
3. [Basic UI Navigation Structure](#prompt-3-basic-ui-navigation-structure)
4. [Local Storage Implementation](#prompt-4-local-storage-implementation)

## Sensor Integration
5. [Location Services](#prompt-5-location-services)
6. [Motion Sensor Framework](#prompt-6-motion-sensor-framework)
7. [Heart Rate Monitoring](#prompt-7-heart-rate-monitoring)
8. [Sensor Data Integration](#prompt-8-sensor-data-integration)

## Session Management
9. [Session Controller](#prompt-9-session-controller)
10. [Basic Session UI](#prompt-10-basic-session-ui)
11. [Session Storage](#prompt-11-session-storage)
12. [Session Metrics Calculation](#prompt-12-session-metrics-calculation)

## Wave Detection and Analysis
13. [Motion Pattern Recognition](#prompt-13-motion-pattern-recognition)
14. [Wave Detection Service](#prompt-14-wave-detection-service)
15. [Wave Storage and Retrieval](#prompt-15-wave-storage-and-retrieval)
16. [Wave Detection Refinement](#prompt-16-wave-detection-refinement)

## Health Integration
17. [HealthKit Authorization](#prompt-17-healthkit-authorization)
18. [Workout Session Recording](#prompt-18-workout-session-recording)
19. [Health Data Integration](#prompt-19-health-data-integration)

## User Interface
20. [Session List View](#prompt-20-session-list-view)
21. [Session Detail View](#prompt-21-session-detail-view)
22. [Map Visualization](#prompt-22-map-visualization)
23. [Insights and Analytics](#prompt-23-insights-and-analytics)

## Data Synchronization
24. [iCloud Setup](#prompt-24-icloud-setup)
25. [Sync Service](#prompt-25-sync-service)
26. [Cross-device Experience](#prompt-26-cross-device-experience)

## Environmental Data
27. [Weather/Conditions API](#prompt-27-weatherconditions-api)
28. [Tide Information](#prompt-28-tide-information)
29. [Spot Identification](#prompt-29-spot-identification)

## Refinement and Optimization
30. [UI Polish](#prompt-30-ui-polish)
31. [Performance Optimization](#prompt-31-performance-optimization)
32. [Error Handling](#prompt-32-error-handling)
33. [Accessibility](#prompt-33-accessibility)

## Quality Assurance and Deployment
34. [Testing Infrastructure](#prompt-34-testing-infrastructure)
35. [Documentation](#prompt-35-documentation)
36. [TestFlight Preparation](#prompt-36-testflight-preparation)
37. [App Store Submission](#prompt-37-app-store-submission)

## Prompt 1: Project Setup

Create a new SwiftUI project for a Surf Tracking Apple Watch app called Dusker with the following specifications:

1. Project name: Dusker
2. Include both watchOS and iOS targets
3. Set up a shared framework for code that will be used by both targets
4. Configure the project with SwiftUI as the UI framework
5. Set minimum OS versions to iOS 16.0 and watchOS 9.0
6. Set up a basic project structure with folders for:
   - Models
   - Views
   - ViewModels
   - Services
   - Utilities
   - Extensions
7. Create a shared Assets catalog with a basic color palette:
   - Primary background: #0A1A2A
   - Accent color: #F89B45
   - Text color (light): #FFFFFF
   - Text color (dark): #222222
8. Create a simple app icon placeholder
9. Add a basic Info.plist with required permissions:
   - Location usage description
   - Health sharing description
   - Motion usage description

For testing:
1. Set up a basic XCTest structure
2. Create a simple test case to verify the project builds correctly

Provide the full project structure and all necessary configuration files.

## Prompt 2: Core Data Models

Building on our Dusker project, implement the Core Data models needed for storing surf session data. Create the following models and relationships:

1. Create a CoreDataManager class responsible for handling the persistent container and context
2. Create the SurfSession entity with the following attributes:
   - id: UUID
   - startDate: Date
   - endDate: Date (optional)
   - location: String
   - latitude: Double
   - longitude: Double
   - totalWaves: Int32
   - maxSpeed: Double
   - avgHeartRate: Double
   - distanceSurfed: Double
   - distancePaddled: Double
   - strokeCount: Int32
   - notes: String (optional)
   - isUploaded: Boolean (default: false)

3. Create the Wave entity with the following attributes:
   - id: UUID
   - startTime: Date
   - endTime: Date
   - distance: Double
   - duration: Double
   - maxSpeed: Double
   - coordinates: Binary Data (to store GPS coordinates)
   - confidence: Double (detection confidence score)

4. Set up a one-to-many relationship between SurfSession and Wave
5. Create preview sample data for testing

6. Write unit tests for:
   - Creation and saving of a SurfSession
   - Adding waves to a session
   - Fetching sessions with waves
   - Deleting a session and ensuring waves are cascaded

Ensure all models conform to Identifiable and provide computed properties for derived metrics.

## Prompt 3: Basic UI Navigation Structure

Now that we have our Core Data models set up, let's create the basic UI navigation structure for both the watchOS and iOS apps.

For watchOS:
1. Create a MainView as the entry point with:
   - A "Start Session" button
   - Navigation link to "History" view
   - Navigation link to "Settings" view
2. Create a SessionHistoryView that displays a list of past sessions
3. Create a SettingsView placeholder
4. Set up a TabView for the session view that will display:
   - Wave count
   - Duration
   - Heart rate
   - Distance

For iOS:
1. Create a TabView with the following tabs:
   - Sessions (list of all surf sessions)
   - Stats (placeholder for future statistics)
   - Settings (placeholder)
2. Create a SessionListView that displays sessions with:
   - Date
   - Location
   - Duration
   - Wave count
3. Create a SessionDetailView placeholder
4. Add navigation from the SessionListView to the SessionDetailView

For both platforms:
1. Create a shared ViewModifier for consistent styling
2. Implement a common color scheme
3. Set up preview providers for all views

Include unit tests for:
1. Navigation flow
2. Correct data passing between views
3. UI rendering tests for main components

Make sure all UI elements follow accessibility best practices and support Dynamic Type.

## Prompt 4: Local Storage Implementation
Building on our Core Data models and UI structure, implement the local storage functionality for the Dusker app:

1. Create a PersistenceController singleton class that:
   - Manages the Core Data stack
   - Provides access to the viewContext
   - Includes methods for background context operations
   - Handles migrations if needed
   - Provides preview context with sample data

2. Implement CRUD operations for SurfSession:
   - fetchSessions(limit: Int? = nil, predicate: NSPredicate? = nil) -> [SurfSession]
   - saveSession(_ session: SurfSession) -> Bool
   - deleteSession(_ session: SurfSession) -> Bool
   - updateSession(_ session: SurfSession) -> Bool

3. Implement CRUD operations for Wave:
   - fetchWaves(forSession session: SurfSession) -> [Wave]
   - saveWave(_ wave: Wave, toSession session: SurfSession) -> Bool
   - deleteWave(_ wave: Wave) -> Bool

4. Create a StorageManager protocol that abstracts the persistence operations:
   - Define protocol methods matching the CRUD operations
   - Create a CoreDataStorageManager implementation
   - Add ability to easily swap persistence mechanisms

5. Implement error handling:
   - Create custom StorageError enum cases
   - Add result types to return success/failure with error details

6. Create the following unit tests:
   - Test creating, reading, updating, and deleting sessions
   - Test wave relationship management
   - Test error handling for invalid operations
   - Test concurrent access and potential race conditions
   - Test sample data generation for previews

7. Create integration tests that:
   - Verify UI components correctly fetch and display stored data
   - Test the full cycle of creating, viewing, and deleting sessions

Ensure thread safety when accessing Core Data and provide methods for both synchronous and asynchronous operations.

## Prompt 5: Location Services
Now, let's implement location services for the Dusker app to track GPS data during surf sessions:

1. Create a LocationManager class that:
   - Conforms to NSObject and implements CLLocationManagerDelegate
   - Provides location authorization management
   - Handles location updates with configurable accuracy
   - Filters out inaccurate readings
   - Provides computed properties for current location, speed, and course
   - Uses Combine publishers for reactive updates

2. Implement GPS coordinate storage:
   - Create a GPSCoordinate struct with latitude, longitude, timestamp, speed, accuracy
   - Implement methods to convert between GPSCoordinate and CLLocation
   - Create an efficient storage format for arrays of coordinates (for Wave entity)

3. Create a LocationPermissionService:
   - Handles requesting appropriate permissions
   - Provides UI for explaining permission requirements
   - Manages "When In Use" vs "Always" permission states
   - Handles degraded location accuracy scenarios

4. Implement background location updates:
   - Configure proper Info.plist settings
   - Add code to manage background location updates
   - Handle suspension and resumption of location services

5. Add location helper utilities:
   - Distance calculation between coordinates
   - Speed calculation
   - Heading/bearing calculation
   - Location accuracy filtering

6. Create the following unit tests:
   - Test location permission workflows
   - Test GPS coordinate conversion and storage
   - Test distance and speed calculations
   - Test filtering of inaccurate readings

7. Create mock implementation for testing:
   - MockLocationManager that provides simulated coordinates
   - Test data generator for simulated surf sessions

8. Update the UI to:
   - Show current location information in the session view
   - Display permission status in settings
   - Provide a way to request permissions

All location services should be battery-efficient, as is possible.

## Prompt 6: Motion Sensor Framework

Let's implement the motion sensor framework that will be crucial for wave detection in our Dusker app:

1. Create a MotionManager class that:
   - Manages access to device motion sensors (accelerometer, gyroscope)
   - Uses CMMotionManager for data collection
   - Configures appropriate update intervals for battery efficiency
   - Provides Combine publishers for motion data updates
   - Filters noise from raw sensor data

2. Implement motion data structures:
   - Create a MotionSample struct to hold acceleration and rotation data with timestamp
   - Add methods to calculate orientation changes from gyroscope data
   - Add methods to detect significant motion events

3. Create a motion recording service:
   - Enable starting/stopping motion data recording
   - Store motion samples efficiently (considering memory usage)
   - Provide functions to analyze recorded motion patterns
   - Use appropriate sampling rates for different activities

4. Implement motion data processing utilities:
   - Low-pass filtering for smoothing accelerometer data
   - Peak detection for identifying paddle strokes
   - Orientation change detection for stand-up moments
   - Motion pattern classification (paddling, riding, idle)

5. Add power management:
   - Adaptive sampling rates based on activity
   - Pause collection during periods of inactivity
   - Resume collection when motion is detected

6. Create unit tests for:
   - Motion data processing algorithms
   - Filtering utilities
   - Pattern recognition functions
   - Battery usage optimization

7. Create mock implementations for testing:
   - MockMotionManager providing simulated data
   - Test data sets for different surf scenarios

8. Update the ViewModel to:
   - Connect motion data to session recording
   - Store relevant motion samples with waves
   - Provide motion state to the UI

Ensure the implementation is optimized for watchOS battery life while maintaining sufficient data for accurate wave detection.

## Prompt 7: Heart Rate Monitoring

Now, let's implement heart rate monitoring for the Dusker app to track physical exertion during surf sessions:

1. Create a HeartRateManager class that:
   - Uses HKHealthStore to access heart rate data
   - Configures heart rate queries with appropriate filters
   - Provides real-time heart rate updates via Combine publishers
   - Calculates rolling averages and zones
   - Handles background reading continuation

2. Implement heart rate data structures:
   - Create a HeartRateSample struct with value, timestamp, and metadata
   - Implement heart rate zone calculation (rest, fat burn, cardio, peak)
   - Add methods for statistical analysis (min, max, avg, variability)

3. Create heart rate visualization components:
   - Implement a HeartRateView that shows current BPM
   - Create a zone indicator with color coding
   - Add a heart rate graph for session summary

4. Implement HealthKit authorization handling:
   - Request appropriate permissions
   - Handle authorization state changes
   - Gracefully degrade functionality if permissions denied

5. Add heart rate data analysis:
   - Calculate calories burned based on heart rate
   - Identify exertion periods during session
   - Correlate heart rate with wave riding

6. Create unit tests for:
   - Heart rate data processing
   - Zone calculations
   - Energy expenditure estimations
   - Permission handling flows

7. Create mock implementations for testing:
   - MockHeartRateManager providing simulated data
   - Test data generator for various intensity profiles

8. Update the UI to:
   - Display current heart rate during sessions
   - Show heart rate zones with visual indicators
   - Include heart rate statistics in session summary

Ensure heart rate monitoring is battery-efficient and continues reliably throughout surf sessions. 

## Prompt 8: Sensor Data Integration

Let's integrate all our sensor components (location, motion, heart rate) into a unified SensorManager for the Dusker app:

1. Create a SensorDataManager protocol that defines:
   - Methods to start/stop all sensors
   - Access to latest sensor values
   - Configuration options for sampling rates
   - Battery optimization settings

2. Implement a concrete SensorDataManagerImpl class that:
   - Composes LocationManager, MotionManager, and HeartRateManager
   - Coordinates startup and shutdown sequences
   - Manages sensor state (active, background, inactive)
   - Handles sensor failures gracefully

3. Create a SensorDataSample struct that combines:
   - Location data (coordinates, speed, course)
   - Motion data (acceleration, rotation)
   - Heart rate data
   - Timestamp and metadata

4. Implement sensor data fusion algorithms:
   - Correlate data from multiple sensors by timestamp
   - Implement a sensor fusion pipeline
   - Apply Kalman filtering for improved accuracy
   - Handle missing data from any sensor

5. Create a SensorDataRecorder service that:
   - Efficiently records integrated sensor data during sessions
   - Uses appropriate data structures for storage
   - Implements data compression for long sessions
   - Provides methods to extract relevant segments

6. Add diagnostic and calibration features:
   - Sensor accuracy assessment
   - Calibration workflows if needed
   - Diagnostic data logging for debugging

7. Create unit tests for:
   - Sensor integration and coordination
   - Data fusion algorithms
   - Recording and retrieval efficiency
   - Error handling and recovery

8. Create integration tests that:
   - Verify all sensors work together
   - Test performance under various conditions
   - Validate battery usage

9. Update the SessionViewModel to:
   - Initialize and manage the SensorDataManager
   - Record and store sensor data with sessions
   - Use sensor data for real-time UI updates

Ensure the integrated solution is resilient to sensor failures and optimizes for both accuracy and battery life.

## Prompt 9: Session Controller

Let's implement the session management functionality for the Dusker app:

1. Create a SessionController class responsible for:
   - Starting a new surf session
   - Pausing/resuming a session
   - Ending a session
   - Managing the session lifecycle
   - Handling app state changes (background/foreground)

2. Implement a SessionState enum:
   - NotStarted
   - Active
   - Paused
   - Finished
   - Error (with associated error)

3. Create a SessionViewModel that:
   - Observes the SessionController
   - Provides session state to the UI
   - Formats session data for display
   - Handles user interactions

4. Implement Apple Watch Water Lock integration:
   - Enable Water Lock when session starts
   - Handle Water Lock exit gracefully
   - Resume session appropriately after Water Lock

5. Add Action Button support for Apple Watch Ultra:
   - Map Action Button to session start/stop
   - Create configurator for system settings
   - Handle button press events

6. Create background session continuation:
   - Implement watchOS background workout session
   - Handle app termination and relaunch
   - Recover session state after relaunch

7. Create session persistence:
   - Save session state periodically
   - Implement auto-save on app transitions
   - Create recovery mechanism for interrupted sessions

8. Create unit tests for:
   - Session state transitions
   - Background handling
   - Water Lock integration
   - Action Button handling

9. Create UI components for session control:
   - Start session button
   - In-progress session controls
   - End session confirmation
   - Session resumption prompt

10. Update the CoreData integration to:
    - Create session entity on start
    - Update entity throughout session
    - Finalize entity on session end

Ensure that session management is robust against app termination, device reboots, and other edge cases.

## Prompt 10: Basic Session UI

Now, let's create the basic session UI components for the Dusker app:

1. For the watchOS app, create the following views:
   - SessionStartView with:
     - Large "Start Session" button
     - Current conditions display (placeholder)
     - Quick access to settings
   - ActiveSessionView with:
     - Time elapsed (HH:MM:SS)
     - Wave count with icon
     - Current heart rate
     - Distance surfed
     - Swipeable pages for additional metrics
   - SessionEndView with:
     - Session summary
     - Save/discard options
     - Quick note entry

2. For the iOS app, create:
   - SessionSummaryView showing:
     - Map with session location
     - Session duration and date
     - Wave count and statistics
     - Heart rate graph
     - Distance metrics

3. Implement common UI components:
   - MetricCard for displaying individual metrics
   - WaveCounter for visualizing wave count
   - SessionTimer for elapsed time
   - HeartRateDisplay with zone indicators

4. Create animations and transitions:
   - Smooth transition between session states
   - Celebrations for achievements (like best wave)
   - Subtle loading indicators for background operations

5. Implement accessibility:
   - VoiceOver support for all metrics
   - Dynamic Type for text elements
   - Appropriate contrast ratios
   - Haptic feedback for important events

6. Create watch-specific UI adaptations:
   - Simplified layouts for different watch sizes
   - Optimized touch targets for wet fingers
   - Always-on display support for active sessions

7. Add UI tests for:
   - Session start workflow
   - Metric display accuracy
   - Navigation between session phases
   - Accessibility compliance

8. Connect the UI to the SessionViewModel:
   - Bind UI elements to view model properties
   - Handle UI events with view model methods
   - Update displays based on session state changes

Ensure the UI is clean, focused, and highly readable in outdoor conditions.

## Prompt 11: Session Storage

Let's enhance our session functionality with robust storage capabilities:

1. Expand the SessionStore service to:
   - Save ongoing session data at regular intervals
   - Provide recovery for interrupted sessions
   - Handle session draft vs. complete sessions
   - Implement batch operations for efficiency

2. Create a SessionRepository protocol with:
   - func createSession() -> SurfSession
   - func saveSession(_ session: SurfSession) -> Result<SurfSession, Error>
   - func loadSession(id: UUID) -> Result<SurfSession, Error>
   - func loadRecentSessions(limit: Int) -> Result<[SurfSession], Error>
   - func updateSession(_ session: SurfSession) -> Result<SurfSession, Error>
   - func deleteSession(_ session: SurfSession) -> Result<Void, Error>

3. Implement a CoreDataSessionRepository conforming to the protocol:
   - Use our existing CoreData stack
   - Add efficient query methods with NSPredicates
   - Implement proper error handling
   - Support background thread operations

4. Create models for session filtering and sorting:
   - SessionFilter with date range, location, metrics filters
   - SessionSortOption enum (date, duration, waves, etc.)
   - Filtering and sorting extension methods

5. Implement a SessionHistoryViewModel:
   - Load sessions with pagination
   - Apply filters and sorting
   - Track session selection
   - Handle deletion and updates

6. Create a SessionHistoryView for iOS:
   - List of sessions with summary information
   - Filter and sort controls
   - Pull-to-refresh functionality
   - Swipe actions for common operations

7. Create a SessionHistoryView for watchOS:
   - Simplified list optimized for watch display
   - Quick actions for session selection
   - Clear loading indicators

8. Implement session export functionality:
   - Generate session summary as shareable image
   - Create JSON export format
   - Add export options to session detail view

9. Add unit tests for:
   - Repository CRUD operations
   - Filtering and sorting logic
   - Data integrity during interruptions
   - Export functionality

Ensure the storage implementation is robust, with proper error handling and recovery mechanisms.

## Prompt 12: Session Metrics Calculation

Let's implement the session metrics calculation functionality for the Dusker app:

1. Create a MetricsCalculator protocol with methods for:
   - calculateDistance(from coordinates: [GPSCoordinate]) -> Double
   - calculateSpeed(from coordinates: [GPSCoordinate]) -> Double
   - calculateMaxSpeed(from coordinates: [GPSCoordinate]) -> Double
   - calculatePaddleDistance(from motionData: [MotionSample]) -> Double
   - calculateStrokeCount(from motionData: [MotionSample]) -> Int
   - calculateHeartRateZones(from heartRateData: [HeartRateSample]) -> HeartRateZones

2. Implement a DefaultMetricsCalculator conforming to the protocol:
   - Use Haversine formula for accurate distance calculation
   - Apply smoothing algorithms for speed calculation
   - Implement stroke detection algorithm for paddle counts
   - Calculate energy expenditure based on heart rate

3. Create data models for metrics:
   - SessionMetrics struct containing all calculated metrics
   - WaveMetrics struct for individual wave statistics
   - HeartRateZones struct with time spent in each zone
   - ActivityMetrics for overall activity (paddling, riding, waiting)

4. Implement real-time metrics calculation:
   - Create a LiveMetricsService that updates as new data arrives
   - Use efficient algorithms suitable for real-time computation
   - Provide Combine publishers for metric updates

5. Create summary metrics calculation:
   - Implement algorithms for session-end summary statistics
   - Add trending and comparison to previous sessions
   - Calculate personal records and achievements

6. Add visualization components:
   - MetricsChart for displaying time-series data
   - HeartRateZoneView showing time in zones
   - ActivityBreakdownView showing time allocation
   - SpeedGraph for wave speed visualization

7. Create unit tests for:
   - Distance calculation accuracy
   - Speed calculation with various sampling rates
   - Stroke counting algorithm
   - Heart rate zone calculation

8. Create benchmarks for performance:
   - Test calculation speed for various session lengths
   - Measure memory usage during calculation
   - Verify battery impact of real-time calculations

Ensure all calculations are accurate, efficient, and handle edge cases appropriately.

## Prompt 13: Motion Pattern Recognition
Now, let's implement motion pattern recognition for detecting paddle, stand-up, and wave riding motions in the Dusker app:

1. Create a MotionPatternRecognizer protocol defining:
   - func detectPaddleMotion(in samples: [MotionSample]) -> [TimeRange]
   - func detectStandUpMotion(in samples: [MotionSample]) -> [TimePoint]
   - func detectRidingMotion(in samples: [MotionSample], with location: [LocationSample]) -> [TimeRange]
   - func detectWaitingMotion(in samples: [MotionSample]) -> [TimeRange]

2. Implement a MachineLearningMotionRecognizer that:
   - Uses Core ML for pattern recognition
   - Processes batches of motion samples
   - Identifies key surfing motion patterns
   - Returns time ranges/points for each pattern

3. Create a simpler HeuristicMotionRecognizer that:
   - Uses threshold-based algorithms for detection
   - Analyzes acceleration patterns for paddling
   - Detects orientation changes for stand-up
   - Combines with speed data for riding confirmation
   - Can be used as fallback or for devices without ML capabilities

4. Implement motion pattern data structures:
   - Create MotionPattern enum (paddling, standUp, riding, waiting)
   - Create MotionEvent struct with pattern type, start/end time, confidence
   - Add methods to correlate events with location data

5. Create preprocessing pipeline for motion data:
   - Implement signal filtering (low-pass, high-pass)
   - Add gravity removal from acceleration
   - Create feature extraction for ML model
   - Implement data normalization

6. Add motion pattern visualization:
   - Create SessionActivityView showing activity timeline
   - Implement color-coding for different activities
   - Add detailed motion analysis view

7. Implement sensitivity settings:
   - Create configurable detection thresholds
   - Implement sensitivity presets (low, medium, high)
   - Add custom sensitivity configuration

8. Write comprehensive unit tests:
   - Test detection accuracy with known patterns
   - Verify integration with location data
   - Test sensitivity configuration
   - Benchmark performance

Create test data sets covering various surfing scenarios for algorithm validation.

## Prompt 14: Wave Detection Service

Let's implement the core wave detection service that will combine motion patterns with GPS data:

1. Create a WaveDetectionService protocol defining:
   - func startDetection()
   - func stopDetection()
   - func getDetectedWaves() -> [Wave]
   - var waveDetected: PassthroughSubject<Wave, Never> { get }
   - var settings: WaveDetectionSettings { get set }

2. Implement a DefaultWaveDetectionService that:
   - Uses MotionPatternRecognizer for motion patterns
   - Combines with LocationManager for speed validation
   - Implements real-time wave detection algorithm
   - Publishes wave detection events
   - Stores detected waves for the session

3. Create a WaveDetectionSettings struct with:
   - sensitivity: DetectionSensitivity (low, medium, high, custom)
   - minWaveDuration: TimeInterval
   - minWaveDistance: Double
   - minWaveSpeed: Double
   - paddleToStandThreshold: Double
   - orientationChangeThreshold: Double
   - Custom thresholds for advanced configuration

4. Implement the wave detection algorithm:
   1. Monitor for paddle motion patterns
   2. Detect sudden orientation change (stand up)
   3. Verify with speed increase from GPS
   4. Track continuation of riding motion
   5. Detect end of wave when speed drops
   6. Calculate wave metrics and confidence score

5. Create a wave validation system:
   - Implement confidence scoring for detected waves
   - Create validation rules based on physics
   - Add options for manual review of low-confidence waves

6. Add wave detection visualization:
   - Create ActiveWaveIndicator for current wave
   - Implement WaveListView for detected waves
   - Add wave playback visualization

7. Implement wave storage:
   - Store wave data with start/end times
   - Save GPS track for each wave
   - Include motion data samples for each wave
   - Calculate and store wave metrics

8. Create comprehensive testing:
   - Unit tests for detection algorithm components
   - Integration tests with simulated sensor data
   - Performance tests for real-time detection
   - Accuracy validation with recorded sessions

Ensure the implementation is efficient enough for real-time use on the Apple Watch while maintaining high detection accuracy.

## Prompt 15: Wave Storage and Retrieval

Now, let's enhance our wave storage and retrieval capabilities for the Dusker app:

1. Create a WaveRepository protocol defining:
   - func saveWave(_ wave: Wave, for session: SurfSession) -> Result<Wave, Error>
   - func loadWaves(for session: SurfSession) -> Result<[Wave], Error>
   - func loadWave(id: UUID) -> Result<Wave, Error>
   - func updateWave(_ wave: Wave) -> Result<Wave, Error>
   - func deleteWave(_ wave: Wave) -> Result<Void, Error>

2. Implement a CoreDataWaveRepository conforming to the protocol:
   - Use our existing CoreData stack
   - Add efficient query methods with NSPredicates
   - Implement proper error handling
   - Support background thread operations

3. Create optimized storage for GPS tracks:
   - Implement a coordinate compression algorithm for efficient storage
   - Create a binary format for storing coordinates in Core Data
   - Add methods to convert between compressed storage and usable formats
   - Include metadata with compression details

4. Implement a WaveViewModel that:
   - Loads wave data from the repository
   - Provides formatted wave metrics for display
   - Handles wave selection and navigation
   - Tracks state for wave detail view

5. Create wave visualization components:
   - WaveTrackView showing GPS track on map
   - WaveMetricsView displaying stats (speed, distance, duration)
   - WaveTimelineView showing waves in session context
   - WaveComparisonView for comparing multiple waves

6. Add batch operations for efficiency:
   - Implement bulk load/save for waves
   - Add caching for frequently accessed waves
   - Create background fetching for wave lists

7. Implement wave data analysis:
   - Calculate wave quality score based on metrics
   - Add classification for wave types
   - Implement trending to compare waves over time
   - Create data visualizations for wave patterns

8. Create the UI for wave management:
   - WaveListView showing waves for a session
   - WaveDetailView with map and metrics
   - WaveEditorView for adjusting wave data
   - WaveFilterView for sorting and filtering

9. Write unit tests for:
   - Repository CRUD operations
   - Coordinate compression/decompression
   - Wave metric calculations
   - Model conversions

Ensure all operations are optimized for watchOS performance and battery life.

## Prompt 16: Wave Detection Refinement

Let's refine our wave detection algorithm to improve accuracy and add configurability:

1. Enhance the WaveDetectionSettings with:
   - Add a TuningProfile struct for storing named configurations
   - Create presets for different surf styles (shortboard, longboard, SUP)
   - Add advanced parameters for fine-tuning detection
   - Implement profile saving and loading

2. Refine the motion pattern detection:
   - Implement multi-stage detection pipeline
   - Add confidence scoring for each pattern
   - Create heuristics to reduce false positives
   - Implement adaptive thresholds based on conditions

3. Create a wave detection debug mode:
   - Add detailed logging of detection events
   - Create a visual timeline of detection stages
   - Save raw sensor data for problematic detections
   - Implement on-device debugging views

4. Add manual wave editing:
   - Create interface for adding missed waves
   - Implement tools to adjust wave start/end points
   - Add wave merging/splitting functionality
   - Create a simple review system for low-confidence waves

5. Implement calibration workflows:
   - Create a session calibration mode
   - Add automated threshold adjustment
   - Implement learning from user corrections
   - Save calibration profiles per board/conditions

6. Enhance noise filtering:
   - Add advanced signal processing filters
   - Implement outlier detection and removal
   - Create adaptive filtering based on conditions
   - Optimize for different motion patterns

7. Improve GPS integration:
   - Implement smarter GPS sampling during wave rides
   - Add fallback detection when GPS is unreliable
   - Create specialized noise filtering for ocean environment
   - Optimize GPS/motion data fusion

8. Create comprehensive test suite:
   - Add tests for edge cases (short waves, wipeouts)
   - Create validation against manually tagged sessions
   - Implement performance benchmarking
   - Add battery usage measurements

Ensure all refinements maintain backwards compatibility with existing data.

## Prompt 17: HealthKit Authorization

Let's implement HealthKit integration for the Dusker app, starting with authorization:

1. Create a HealthKitManager class responsible for:
   - Requesting necessary HealthKit permissions
   - Checking authorization status
   - Managing authorization state changes
   - Providing access to health data types

2. Implement the following HealthKit permissions:
   - Read access to heart rate data
   - Read/write access for workout data
   - Read access to active energy burned
   - Write access for surfing workout type

3. Create a HealthKitAuthorizationView:
   - Clear explanation of benefits
   - Visual representation of requested data types
   - Simple permission request buttons
   - Alternative flows if permissions denied

4. Implement a HealthKitViewModel:
   - Track authorization status
   - Handle permission requests
   - Provide UI state for authorization views
   - Implement error handling for authorization failures

5. Create authorization utilities:
   - Granular permission requests
   - Permission request retry logic
   - Limited functionality mode for partial permissions
   - Clear user messaging about missing permissions

6. Add integration with app settings:
   - Health integration toggle in settings
   - Permission management section
   - Data sharing preferences
   - Privacy explanation screen

7. Implement graceful degradation:
   - Fallback heart rate calculation if not available
   - Alternative calorie estimation methods
   - Clear UI indicators for unavailable data
   - Prompts to enable permissions when relevant

8. Write unit tests for:
   - Authorization request workflows
   - Status change handling
   - UI state management
   - Error scenarios

Ensure all HealthKit usage complies with Apple's privacy guidelines and provide clear user communication about data usage.

## Prompt 18: Workout Session Recording

Now, let's implement workout session recording with HealthKit for the Dusker app:

1. Create a WorkoutSessionManager class that:
   - Creates and manages HKWorkoutSession
   - Handles workout lifecycle (start, pause, resume, end)
   - Manages workout state during app lifecycle events
   - Saves completed workouts to HealthKit

2. Implement a WorkoutConfiguration:
   - Set location type to outdoor
   - Configure for surfing activity type
   - Set appropriate display settings
   - Configure for swimming mode when available

3. Create a LiveWorkoutDataStore that:
   - Collects heart rate during workout
   - Tracks active and resting energy
   - Records distance metrics
   - Handles sensor data collection

4. Implement workout builders:
   - Create HKWorkoutBuilder configuration
   - Add appropriate workout events
   - Include route data for waves
   - Set correct metadata and workout type

5. Add HealthKit sample generators:
   - Create heart rate samples from recorded data
   - Generate distance samples for paddling/riding
   - Create energy burned samples
   - Add swim stroke count samples

6. Implement workout summary creation:
   - Calculate total statistics for the session
   - Generate workout summary view
   - Create sharing options for workout data
   - Add comparison with previous workouts

7. Create workout state synchronization:
   - Sync SurfSession state with HKWorkoutSession
   - Handle transitions between states
   - Manage recovery from interruptions
   - Ensure data consistency between systems

8. Write comprehensive tests:
   - Test workout lifecycle management
   - Verify sample generation accuracy
   - Test state synchronization
   - Validate summary calculation

Ensure the implementation follows Apple's best practices for HealthKit workout sessions.

## Prompt 19: Health Data Integration

Let's integrate health data more deeply into the Dusker app:

1. Create a HealthDataIntegrator class that:
   - Retrieves relevant health data for context
   - Correlates health metrics with surf performance
   - Provides insights based on health trends
   - Calculates surfing-specific fitness metrics

2. Implement health data retrieval for:
   - Recent cardio fitness level (VO2 max)
   - Resting heart rate trends
   - Recovery heart rate patterns
   - Overall activity levels

3. Create health-based insights:
   - Generate fatigue level estimates
   - Calculate optimal session duration based on fitness
   - Identify performance trends correlated with health metrics
   - Provide recovery recommendations

4. Implement a HealthInsightsView:
   - Visualize health data relevant to surfing
   - Show performance correlations
   - Display recovery status
   - Provide actionable insights

5. Add health data visualization components:
   - HeartRateVariabilityChart for recovery tracking
   - FitnessLevelView for cardio fitness trends
   - RecoveryIndicator for session readiness
   - PerformanceTrendView correlating health and surfing

6. Create a health data dashboard:
   - Summary of surf-relevant health metrics
   - Recent trends visualization
   - Session readiness indicator
   - Performance predictions

7. Implement health data export:
   - Export surf workout data to third-party fitness apps
   - Create shareable health and performance reports
   - Generate progress tracking visualizations
   - Add health data to session summaries

8. Write tests for:
   - Health data retrieval accuracy
   - Insight generation algorithms
   - Data privacy and permissions
   - UI rendering with various health data states

Ensure all health integrations respect user privacy and provide actionable, relevant information for surfers.

## Prompt 20: Session List View

Let's create a comprehensive session list view for the iOS app:

1. Create a SessionListViewModel that:
   - Loads sessions from the repository
   - Handles filtering and sorting
   - Manages selection and navigation
   - Provides formatted data for display

2. Implement a SessionListView with:
   - Clean, card-based layout for sessions
   - Summary information (date, location, waves, duration)
   - Visual indicators for session quality
   - Pull-to-refresh and infinite scrolling
   - Sticky headers for date grouping

3. Add filtering and sorting:
   - Create a FilterBarView with common filters
   - Implement an advanced FilterSheetView
   - Add sorting options (date, waves, duration, location)
   - Create filter persistence between app launches

4. Implement list organization:
   - Group sessions by month/year
   - Add location grouping option
   - Create favorites system
   - Implement tags/categories for sessions

5. Add list interactions:
   - Swipe actions for common operations
   - Long-press context menu
   - Multi-select mode for batch operations
   - Drag and drop for manual ordering

6. Create visual enhancements:
   - Session thumbnail maps
   - Wave count visualization
   - Performance indicator icons
   - Weather condition icons

7. Implement search functionality:
   - Full-text search across sessions
   - Search by date, location, tags
   - Recent searches storage
   - Search suggestions

8. Add list customization:
   - Configurable display density
   - Custom sort/filter presets
   - Display preferences (metrics to show)
   - List view vs. grid view toggle

9. Write tests for:
   - List loading and pagination
   - Filtering and sorting logic
   - Search functionality
   - UI interactions

Ensure the list view is performant even with hundreds of sessions and implements all iOS list view best practices.

## Prompt 21: Session Detail View

Now, let's implement a comprehensive session detail view for the iOS app:

1. Create a SessionDetailViewModel that:
   - Loads complete session data with waves
   - Calculates detailed session metrics
   - Manages view state and navigation
   - Handles user interactions

2. Implement a SessionDetailView with a tabbed interface:
   - Overview tab with key metrics and map
   - Waves tab with wave list and details
   - Insights tab with performance analysis
   - Health tab with heart rate and exertion data

3. Create the Overview tab with:
   - Header with location, date, and duration
   - Map view showing session area and wave tracks
   - Key metrics cards (waves, distance, speed)
   - Weather/conditions summary
   - Session notes section

4. Implement the Waves tab with:
   - Wave list sorted by time
   - Wave metrics for each entry
   - Wave selection for detailed view
   - Wave comparison tool
   - Wave track visualization

5. Create the Insights tab with:
   - Performance trends visualization
   - Session comparison with average/best
   - Activity breakdown chart
   - Suggested improvements

6. Implement the Health tab with:
   - Heart rate graph with zones
   - Calories burned metrics
   - Exertion level visualization
   - Recovery recommendation

7. Add sharing functionality:
   - Generate shareable session summary
   - Export session data options
   - Share individual waves
   - Create custom share layouts

8. Implement editing capabilities:
   - Session metadata editor
   - Wave management tools
   - Note taking interface
   - Tag/categorization system

9. Write tests for:
   - Detail view loading and display
   - Tab navigation and state preservation
   - Metric calculations
   - Sharing functionality

Ensure the detail view provides comprehensive information while maintaining a clean, intuitive interface.

## Prompt 22: Map Visualization

Let's implement advanced map visualization for the Dusker app:

1. Create a SessionMapViewModel that:
   - Manages map state and configuration
   - Loads and processes GPS data for display
   - Handles user interactions with the map
   - Controls visualization options

2. Implement a SessionMapView using MapKit:
   - Display session location with custom annotation
   - Show wave tracks with distinct styling
   - Implement paddle path visualization
   - Add heat map for activity intensity

3. Create specialized map annotations:
   - SessionLocationAnnotation with session info
   - WaveStartAnnotation for wave takeoff points
   - WaveEndAnnotation for wave end points
   - Custom annotation clusters for dense sessions

4. Implement track visualization:
   - Create colored polylines for waves based on speed
   - Style paddle paths differently from wave rides
   - Add animation options for playback
   - Implement time-based track filtering

5. Add map control UI:
   - Layer toggle controls (waves, paddle paths, heatmap)
   - Time slider for session playback
   - Wave selection tools
   - Map style options (standard, satellite, hybrid)

6. Create a wave playback system:
   - Step-by-step wave ride visualization
   - Speed indicator during playback
   - Timeline marker for current position
   - Playback controls (play, pause, speed)

7. Implement map optimization:
   - Efficient rendering for long sessions
   - Level-of-detail management for tracks
   - Memory optimization for large datasets
   - Caching strategy for map data

8. Add interactive features:
   - Tap on track for details
   - Wave selection and highlighting
   - Pinch-to-zoom on waves
   - Measurement tools

9. Write tests for:
   - Map rendering performance
   - Track visualization accuracy
   - User interaction handling
   - Memory usage optimization

Ensure the map visualization is performant even with complex sessions and provides meaningful insights into the surf session. Prefer Non-Google map services like Mapbox.

## Prompt 23: Insights and Analytics
Let's implement an insights and analytics system for the Dusker app:

1. Create an AnalyticsEngine class that:
   - Processes historical session data
   - Calculates trends and patterns
   - Identifies performance insights
   - Generates recommendations

2. Implement data analysis algorithms:
   - Session performance scoring
   - Wave quality assessment
   - Progress tracking over time
   - Pattern recognition for surf style

3. Create an InsightsViewModel that:
   - Provides formatted insights data
   - Manages insight categories and filtering
   - Handles user interaction with insights
   - Updates as new sessions are added

4. Implement visualization components:
   - TrendChartView for metrics over time
   - PerformanceRadarView for skill breakdown
   - ProgressBarView for goal tracking
   - ComparisonChartView for benchmarking

5. Create insight categories:
   - Performance insights (speed, wave count, etc.)
   - Activity insights (paddle efficiency, wait time)
   - Location insights (spot performance comparison)
   - Health insights (exertion, recovery patterns)

6. Implement a recommendation engine:
   - Generate actionable recommendations
   - Provide personalized surf tips
   - Suggest optimal conditions based on history
   - Identify areas for improvement

7. Create an InsightsView with:
   - Dashboard of key insights
   - Categorized insight browsing
   - Detailed insight expansion
   - Interactive data exploration

8. Add goal tracking:
   - Custom goal setting interface
   - Progress visualization
   - Achievement celebration
   - Goal recommendation based on performance

9. Write tests for:
   - Analysis algorithm accuracy
   - Insight generation logic
   - Visualization rendering
   - Recommendation relevance

Ensure the insights are actionable, relevant to surfers, and presented in an intuitive, visually appealing way.

## Prompt 24: iCloud Setup

Let's implement iCloud integration for the Dusker app to enable cross-device synchronization:

1. Create a CloudKitManager class responsible for:
   - Setting up CloudKit container and database
   - Managing public vs. private database access
   - Handling account status changes
   - Implementing retry and error handling logic

2. Define CloudKit record types:
   - CKSessionRecord with session attributes
   - CKWaveRecord with wave data
   - CKUserSettingsRecord for app settings
   - CKSyncMetadataRecord for tracking sync state

3. Implement record conversion utilities:
   - Convert between Core Data entities and CK records
   - Handle relationship mapping
   - Implement efficient binary data conversion
   - Add metadata for sync conflict resolution

4. Create a sync token management system:
   - Track last sync timestamps
   - Store and retrieve server change tokens
   - Implement incremental sync for efficiency
   - Handle token invalidation scenarios

5. Set up CloudKit subscriptions:
   - Register for remote change notifications
   - Create subscription for each record type
   - Implement notification processing
   - Add background refresh capabilities

6. Create a CloudKitSyncCoordinator:
   - Manage overall sync process
   - Handle push operations (local to cloud)
   - Process pull operations (cloud to local)
   - Implement conflict resolution strategies

7. Add sync UI components:
   - SyncStatusView showing current state
   - SyncControlsView for manual sync
   - CloudAccountView for account info
   - SyncErrorView for troubleshooting

8. Implement sync privacy controls:
   - Selective sync options (which data to sync)
   - Privacy settings for location data
   - Data retention policies
   - Local-only mode option

9. Write comprehensive tests:
   - Record conversion accuracy
   - Sync coordinator workflows
   - Conflict resolution scenarios
   - Network failure handling

Ensure the iCloud implementation follows Apple's best practices and provides a seamless experience across devices.

## Prompt 25: Sync Service

Let's build a comprehensive sync service that manages data synchronization between devices:

1. Create a SyncService protocol defining:
   - func startSync() -> AnyPublisher<SyncProgress, Error>
   - func cancelSync()
   - func scheduleBackgroundSync()
   - var syncStatus: CurrentValueSubject<SyncStatus, Never> { get }
   - var lastSyncDate: Date? { get }

2. Implement a CloudKitSyncService conforming to the protocol:
   - Use CloudKitManager for iCloud operations
   - Implement bi-directional sync algorithm
   - Handle background fetch scheduling
   - Manage sync state persistence

3. Create data models for sync:
   - SyncStatus enum (idle, syncing, failed, completed)
   - SyncProgress struct with percent and current operation
   - SyncError enum with detailed error cases
   - SyncMetadata for tracking sync state

4. Implement a multi-stage sync process:
   1. Push local changes to cloud
   2. Fetch remote changes
   3. Apply remote changes locally
   4. Resolve conflicts
   5. Update local metadata

5. Create a conflict resolution system:
   - Define conflict resolution strategies (newest wins, manual merge)
   - Implement three-way merge for compatible changes
   - Create conflict presentation UI
   - Store and apply resolution decisions

6. Add background sync capabilities:
   - Register for background refresh
   - Implement silent push notification handling
   - Create energy-efficient sync scheduling
   - Handle background task completion

7. Implement error recovery:
   - Create automatic retry for transient errors
   - Implement exponential backoff strategy
   - Add partial sync completion handling
   - Create sync repair mechanisms

8. Create sync monitoring and debugging:
   - Add detailed sync logging
   - Create sync history tracking
   - Implement sync diagnostics tools
   - Add performance monitoring

9. Write tests for:
   - Full sync cycle operations
   - Conflict detection and resolution
   - Background sync scheduling
   - Error handling and recovery

Ensure the sync service is reliable, efficient with network and battery usage, and provides clear feedback to the user.

## Prompt 26: Cross-device Experience

Let's enhance the Dusker app with a seamless cross-device experience:

1. Implement Handoff support:
   - Enable session continuation between devices
   - Create NSUserActivity for current app state
   - Handle activity restoration
   - Add deep linking to specific content

2. Create a shared UI component library:
   - Implement consistent styling across platforms
   - Create adaptive layouts for different screen sizes
   - Design shared navigation patterns
   - Ensure consistent terminology and iconography

3. Implement settings synchronization:
   - Sync user preferences across devices
   - Create a SettingsStore with CloudKit backing
   - Handle settings conflicts
   - Provide per-device override options

4. Add Watch-to-Phone communication:
   - Implement WCSession for direct device communication
   - Create a MessageService for reliable transfers
   - Handle app state synchronization
   - Implement file transfers for sensor data

5. Create Continuity features:
   - Add Universal Clipboard support for session data
   - Implement Continuity Camera for adding photos
   - Create shared credentials handling
   - Add proximity-based device switching

6. Implement a unified notification system:
   - Synchronize notifications across devices
   - Create rich notification content
   - Handle notification actions consistently
   - Implement notification muting per device

7. Add shared state management:
   - Create a StateCoordinator for cross-device state
   - Implement real-time state synchronization
   - Handle offline state divergence
   - Create state reconciliation algorithms

8. Implement cross-device authentication:
   - Create seamless sign-in across devices
   - Implement secure credential sharing
   - Add biometric authentication on supported devices
   - Create account management interface

9. Write tests for:
   - Handoff functionality
   - Settings synchronization
   - Inter-device communication
   - State consistency across devices

Ensure the cross-device experience feels natural and consistent, with appropriate adaptations for each platform's capabilities.

## Prompt 27: Weather/Conditions API

Let's implement weather and surf conditions integration for the Dusker app:

1. Create a WeatherService protocol defining:
   - func getCurrentConditions(at location: CLLocation) -> AnyPublisher<WeatherConditions, Error>
   - func getForecast(at location: CLLocation, days: Int) -> AnyPublisher<[ForecastDay], Error>
   - func getHistoricalConditions(at location: CLLocation, date: Date) -> AnyPublisher<WeatherConditions, Error>

2. Research and implement API clients for potential providers:
   - Create a WeatherKitService using Apple's WeatherKit API
   - Implement a SurflineService for surf-specific data (if API available)
   - Create a NOAAService for tide and marine data
   - Add a StormglassService as another option

3. Create data models for weather and conditions:
   - WeatherConditions with temperature, wind, precipitation
   - SwellConditions with height, period, direction
   - TideConditions with current level, next high/low
   - ForecastDay with hourly predictions

4. Implement data visualization components:
   - WeatherSummaryView with current conditions
   - SwellChartView showing swell components
   - TideGraphView with tide curve
   - WindCompassView showing wind direction and speed

5. Create a ConditionsViewModel that:
   - Manages data loading from services
   - Combines data from multiple sources
   - Handles caching and refresh policies
   - Provides formatted data for UI

6. Add location-based condition loading:
   - Automatically load conditions for session location
   - Implement location favorites for quick checking
   - Add geofencing for nearby spot alerts
   - Create location search for checking other spots

7. Implement forecast integration:
   - Add forecast view for upcoming days
   - Create optimal conditions highlighting
   - Implement conditions comparison with historical data
   - Add surf quality prediction based on conditions

8. Create offline capabilities:
   - Cache recent conditions data
   - Implement tide prediction for offline use
   - Add historical data persistence
   - Create data prefetching for favorite locations

9. Write tests for:
   - API client functionality
   - Data model conversions
   - Caching and persistence
   - UI rendering with various data states

Ensure the weather integration is battery and network efficient, with appropriate caching and update frequencies.

## Prompt 28: Tide Information

Let's implement comprehensive tide information integration for the Dusker app:

1. Create a TideService protocol defining:
   - func getCurrentTide(at location: CLLocation) -> AnyPublisher<TideInfo, Error>
   - func getTidePredictions(at location: CLLocation, start: Date, end: Date) -> AnyPublisher<[TidePrediction], Error>
   - func getNextHighLow(at location: CLLocation) -> AnyPublisher<TideExtreme, Error>
   - func getTideStations(near location: CLLocation) -> AnyPublisher<[TideStation], Error>

2. Implement a NOAATideService conforming to the protocol:
   - Access NOAA CO-OPS API for US tide data
   - Handle API authentication and rate limiting
   - Implement data parsing and validation
   - Add error handling and recovery

3. Create alternative tide data sources:
   - Implement a WorldTidesService for global coverage
   - Create a TideCalculator for offline predictions
   - Add a UserReportedTideService for community data
   - Implement provider selection based on location

4. Create tide data models:
   - TideInfo with current height, status, and reference levels
   - TidePrediction with height and timestamp
   - TideExtreme with high/low type, height, and time
   - TideStation with location, name, and metadata

5. Implement tide visualization components:
   - TideGraphView showing curve with current position
   - TideClockView showing time to next extreme
   - TideTableView with tabular data
   - TideStatusView for quick reference

6. Create a TideViewModel that:
   - Manages tide data loading and caching
   - Calculates derived tide metrics
   - Schedules updates at appropriate intervals
   - Provides formatted data for UI components

7. Add session-specific tide integration:
   - Automatically load tide data for session location
   - Associate tide information with sessions
   - Correlate wave performance with tide state
   - Create tide recommendations based on history

8. Implement tide complications for Apple Watch:
   - Create tide graph complication
   - Add high/low tide time complication
   - Implement tide direction indicator
   - Create tide height complication

9. Write tests for:
   - Tide data retrieval and parsing
   - Prediction algorithm accuracy
   - UI rendering with various tide states
   - Offline capability fallbacks

Ensure tide information is accurate, visually intuitive, and relevant to surfing conditions assessment.

## Prompt 29: Spot Identification

Let's implement surf spot identification and management for the Dusker app:

1. Create a SpotService protocol defining:
   - func identifySpot(at location: CLLocation) -> AnyPublisher<SurfSpot?, Error>
   - func getNearbySpots(near location: CLLocation, radius: Double) -> AnyPublisher<[SurfSpot], Error>
   - func searchSpots(query: String) -> AnyPublisher<[SurfSpot], Error>
   - func saveUserSpot(_ spot: SurfSpot) -> AnyPublisher<SurfSpot, Error>

2. Implement a spot database:
   - Create a bundled database of known surf spots
   - Implement efficient spatial indexing
   - Add metadata like spot type, difficulty, and features
   - Include region-specific spot information

3. Create a SpotIdentificationService that:
   - Uses GPS coordinates to identify known spots
   - Implements proximity matching algorithm
   - Falls back to reverse geocoding for unknown locations
   - Handles ambiguous location resolution

4. Implement user-defined spots:
   - Create interface for adding custom spots
   - Allow editing of spot metadata
   - Implement spot favoriting
   - Add custom notes for spots

5. Create data models for spots:
   - SurfSpot with name, coordinates, and metadata
   - SpotCategory enum (beach break, reef, point, etc.)
   - SpotDifficulty enum (beginner, intermediate, advanced)
   - SpotFeatures struct with characteristics

6. Implement spot visualization:
   - SpotMapView showing spot location with details
   - SpotListView for browsing nearby spots
   - SpotDetailView with comprehensive information
   - SpotConditionsView showing current conditions

7. Create a SpotViewModel that:
   - Manages spot identification and loading
   - Provides formatted spot data for UI
   - Handles user interaction with spots
   - Manages spot history and favorites

8. Add spot analytics:
   - Track performance at different spots
   - Create spot comparison tools
   - Implement spot recommendations based on conditions
   - Add spot statistics for session planning

9. Write tests for:
   - Spot identification accuracy
   - Database query performance
   - Custom spot management
   - UI rendering with various spot data

Ensure the spot identification is accurate, provides valuable context for sessions, and enhances the overall app experience.

## Prompt 30: UI Polish

Let's implement UI polish and refinement for the Dusker app:

1. Create a comprehensive design system:
   - Define a complete color palette with semantic naming
   - Create typography styles with proper scaling
   - Implement consistent spacing system
   - Design component library with reusable elements

2. Refine typography and text rendering:
   - Implement proper Dynamic Type support
   - Create custom fonts with efficient loading
   - Add text styles for different contexts
   - Ensure legibility in outdoor conditions

3. Implement animations and transitions:
   - Create custom transitions between screens
   - Add micro-interactions for feedback
   - Implement data visualization animations
   - Create celebration animations for achievements

4. Polish watch-specific UI:
   - Optimize for different watch sizes
   - Implement Digital Crown interactions
   - Create Always-On display optimizations
   - Design water-friendly touch targets

5. Enhance visual feedback:
   - Implement haptic feedback patterns
   - Create sound design for key interactions
   - Add visual state indicators
   - Design progress visualizations

6. Refine data visualization:
   - Create custom chart styles
   - Implement interactive data exploration
   - Add visual hierarchy to complex data
   - Design intuitive visualizations for surf metrics

7. Improve loading states:
   - Design skeleton loading screens
   - Implement progressive loading patterns
   - Create custom loading animations
   - Add data preview during loading

8. Polish layout and composition:
   - Ensure consistent margins and alignment
   - Implement proper landscape support on iOS
   - Create responsive layouts for all screens
   - Design consistent card and list styles

9. Write UI tests:
   - Test rendering on different device sizes
   - Verify dynamic type scaling
   - Test animations and transitions
   - Validate visual consistency across the app

Ensure the UI feels polished, cohesive, and purpose-built for surfers using the app in challenging outdoor conditions.

## Prompt 31: Performance Optimization

Let's optimize the performance of the Dusker app, with a particular focus on battery efficiency:

1. Implement intelligent sensor usage:
   - Create adaptive sensor sampling rates based on activity
   - Implement sensor coalescing for efficiency
   - Add motion-based activation/deactivation
   - Create power states with different sensor profiles

2. Optimize GPS usage:
   - Implement smart GPS sampling strategies
   - Create geofencing-based GPS activation
   - Add accuracy-based power management
   - Implement batch processing of location updates

3. Refine background processing:
   - Create efficient background task scheduling
   - Implement work batching for power efficiency
   - Add background task prioritization
   - Create power-aware processing pipeline

4. Optimize UI rendering:
   - Implement view recycling for lists
   - Add image caching and optimization
   - Create efficient drawing techniques for visualizations
   - Implement lazy loading for complex views

5. Improve data handling:
   - Implement efficient serialization techniques
   - Create tiered storage strategy
   - Add data prefetching and precomputation
   - Optimize database queries and indexing

6. Create a performance monitoring system:
   - Track battery usage per component
   - Measure and log processing time for key operations
   - Implement memory usage monitoring
   - Create performance regression tests

7. Add power saving modes:
   - Implement user-selectable power profiles
   - Create automatic power saving based on battery level
   - Add session-duration-aware power management
   - Implement critical battery handling

8. Optimize network usage:
   - Implement efficient data compression
   - Create background transfer scheduling
   - Add connection-aware sync strategies
   - Implement data prioritization for limited connectivity

9. Write performance tests:
   - Benchmark key algorithms
   - Measure battery impact of core features
   - Test performance on older devices
   - Create scalability tests for large datasets

Ensure all optimizations maintain the core functionality and accuracy while extending battery life for longer surf sessions.

## Prompt 32: Error Handling

Let's implement comprehensive error handling and recovery mechanisms for the Dusker app:

1. Create a unified error system:
   - Define domain-specific error enums (NetworkError, StorageError, SensorError, etc.)
   - Implement error categorization (recoverable, warning, critical)
   - Create an ErrorManager for centralized handling
   - Add error logging and reporting infrastructure

2. Implement user-facing error presentation:
   - Create contextual error messages with clear actions
   - Design error states for different UI components
   - Implement progressive disclosure of error details
   - Add visual differentiation by error severity

3. Create recovery mechanisms:
   - Implement automatic retry logic for transient errors
   - Add manual recovery workflows for user-resolvable issues
   - Create data repair tools for corruption scenarios
   - Implement session recovery after crashes

4. Handle device-specific errors:
   - Create watchOS-specific error handling
   - Implement recovery for watch connectivity issues
   - Add low battery contingency workflows
   - Handle thermal throttling gracefully

5. Implement sensor error management:
   - Create fallback mechanisms for sensor failures
   - Implement degraded operation modes
   - Add sensor calibration and recovery tools
   - Design clear messaging for sensor permission issues

6. Create network error handling:
   - Implement offline mode with clear indicators
   - Add connectivity recovery procedures
   - Create queuing system for pending operations
   - Implement partial data handling for incomplete responses

7. Add background error management:
   - Create mechanisms to surface background errors
   - Implement state reconciliation after failures
   - Add critical error notifications
   - Design background retry strategies

8. Implement diagnostic tools:
   - Create error logs viewer for troubleshooting
   - Add device state reporting for support
   - Implement diagnostic data collection
   - Create self-healing mechanisms where possible

9. Write comprehensive tests:
   - Test error detection and handling
   - Validate recovery mechanisms
   - Verify error message clarity
   - Test edge cases and failure scenarios

Ensure the error handling system is comprehensive but non-intrusive, with a focus on maintaining user trust through transparency and recovery options.

## Prompt 33: Accessibility

Let's implement comprehensive accessibility features for the Dusker app:

1. Implement VoiceOver support:
   - Add proper accessibility labels and hints
   - Create meaningful accessibility traits
   - Implement custom rotors for navigation
   - Design custom accessibility announcements

2. Enhance Dynamic Type support:
   - Ensure all text scales appropriately
   - Test layout with largest content sizes
   - Implement custom scaling for graphical elements
   - Create responsive layouts for different text sizes

3. Add additional vision accommodations:
   - Implement high contrast mode
   - Support system contrast settings
   - Add color blind friendly visualizations
   - Create alternative text representations of visual data

4. Implement motion accessibility:
   - Honor Reduce Motion system setting
   - Create alternative non-animated transitions
   - Add static alternatives to animations
   - Implement reduced motion data visualizations

5. Add hearing and speech accommodations:
   - Create visual alternatives for audio feedback
   - Implement closed captioning for any audio
   - Add customizable haptic feedback
   - Support system audio accommodations

6. Enhance motor control accessibility:
   - Implement larger touch targets
   - Add alternative input methods
   - Create assistive touch support
   - Implement dwell control compatibility

7. Design cognitive accessibility features:
   - Create consistent and predictable interfaces
   - Implement progress indicators for complex tasks
   - Add memory aids for multi-step processes
   - Support text-to-speech for all content

8. Create an accessibility settings panel:
   - Add app-specific accessibility options
   - Implement accessibility profiles
   - Create direct access to system settings
   - Add accessibility feedback mechanism

9. Write accessibility tests:
   - Test with VoiceOver enabled
   - Validate UI with different text sizes
   - Verify color contrast compliance
   - Test alternative input methods

Ensure the app is fully accessible to users with diverse abilities and preferences, following WCAG guidelines and Apple's accessibility best practices.

## Prompt 34: Testing Infrastructure

Let's create a comprehensive testing infrastructure for the Dusker app:

1. Implement unit testing framework:
   - Set up XCTest for both targets
   - Create test plans for different scenarios
   - Implement code coverage reporting
   - Add continuous integration configuration

2. Create a mock system for testing:
   - Implement protocol-based dependency injection
   - Create mock implementations of all services
   - Add configurable test data generators
   - Implement predictable randomization for testing

3. Implement UI testing:
   - Set up XCUITest for interface testing
   - Create page objects for test structure
   - Implement screenshot-based testing
   - Add accessibility audit tests

4. Create integration tests:
   - Test communication between components
   - Implement end-to-end workflow tests
   - Add cross-device interaction tests
   - Create background processing tests

5. Implement performance testing:
   - Create benchmarks for critical algorithms
   - Add memory leak detection
   - Implement battery usage tests
   - Create load testing for data handling

6. Add sensor simulation:
   - Implement simulated motion data playback
   - Create GPS track simulation
   - Add heart rate data simulation
   - Design sensor error simulation

7. Create test data sets:
   - Generate realistic surf session data
   - Create edge case test scenarios
   - Implement progressive test complexity
   - Add internationalization test data

8. Implement test automation:
   - Create test pipeline configuration
   - Add automated regression testing
   - Implement test reporting
   - Create notification system for test failures

9. Add specialized testing tools:
   - Implement wave detection algorithm testing
   - Create GPS accuracy validation
   - Add database performance testing
   - Implement sync conflict testing

Ensure the testing infrastructure is comprehensive, maintainable, and provides quick feedback during development.

## Prompt 35: Documentation

Let's create comprehensive documentation for the Dusker app:

1. Implement code documentation:
   - Add inline comments for complex algorithms
   - Create method documentation with parameter descriptions
   - Implement class/protocol overview documentation
   - Add code examples for key components

2. Create architecture documentation:
   - Document high-level app architecture
   - Create component relationship diagrams
   - Add data flow documentation
   - Implement state management overview

3. Create API documentation:
   - Document all public interfaces
   - Create usage examples for key APIs
   - Add parameter validation details
   - Implement error handling documentation

4. Write developer guides:
   - Create onboarding documentation for new developers
   - Implement coding standards guide
   - Add troubleshooting guides
   - Create performance optimization guidelines

5. Create user documentation:
   - Implement in-app help system
   - Create user guide with key features
   - Add tutorial content for new users
   - Create FAQ documentation

6. Implement technical diagrams:
   - Create class diagrams for key subsystems
   - Add sequence diagrams for complex workflows
   - Implement state machine diagrams
   - Create data model visualization

7. Add build and deployment documentation:
   - Document build configuration
   - Create deployment checklist
   - Add App Store submission guide
   - Implement version management documentation

8. Create testing documentation:
   - Document test coverage strategy
   - Add test data generation guidelines
   - Create test case writing guide
   - Document CI/CD integration

9. Implement documentation automation:
   - Set up automated documentation generation
   - Create documentation validation tools
   - Implement documentation versioning
   - Add documentation search capabilities

Ensure all documentation is clear, accurate, and maintained alongside code changes.

## Prompt 36: TestFlight Preparation

Let's prepare the Dusker app for TestFlight beta testing:

1. Configure app metadata:
   - Set proper bundle identifier
   - Create marketing version and build number scheme
   - Add privacy policy URL
   - Configure age rating information

2. Prepare beta testing assets:
   - Create TestFlight app description
   - Add beta app icon (if different from release)
   - Implement beta watermark on UI
   - Create beta splash screen with version info

3. Implement beta user management:
   - Create internal testing group
   - Set up external testing groups by user type
   - Add testing distribution rules
   - Create tester onboarding documentation

4. Add beta feedback mechanisms:
   - Implement in-app feedback form
   - Create screenshot annotation tools
   - Add crash reporting with context
   - Implement beta-specific logging

5. Create beta testing instructions:
   - Write clear test scenarios
   - Create guided testing workflows
   - Add known issues documentation
   - Implement survey questions for testers

6. Configure build settings:
   - Set up proper signing for TestFlight
   - Create beta-specific build configurations
   - Add debug information for beta builds
   - Implement beta feature flags

7. Prepare analytics for beta:
   - Configure analytics specifically for beta
   - Implement session recording (with consent)
   - Add usage metrics collection
   - Create beta user cohort tracking

8. Create beta release process:
   - Document build and submission workflow
   - Implement changelog generation
   - Create release notes template
   - Add version history tracking

9. Set up beta testing infrastructure:
   - Create feedback collection system
   - Implement issue tracking integration
   - Add automated build distribution
   - Create beta testing dashboard

Ensure the TestFlight preparation creates a seamless experience for testers while providing valuable feedback for development.

## Prompt 37: App Store Submission

Let's prepare the Dusker app for App Store submission:

1. Create App Store assets:
   - Design App Store icon (1024x1024)
   - Create app preview videos for each device
   - Design App Store screenshots for all devices
   - Prepare promotional artwork

2. Write App Store metadata:
   - Create compelling app description
   - Write keyword-optimized subtitle
   - Craft concise promotional text
   - Create keyword list for search optimization

3. Configure app submission settings:
   - Set pricing and availability
   - Configure app rating information
   - Add copyright information
   - Set up territories and localization

4. Prepare legal documentation:
   - Create comprehensive privacy policy
   - Write terms of service
   - Add attribution for third-party components
   - Create GDPR compliance documentation

5. Implement App Store requirements:
   - Add proper data collection disclosure
   - Create App Tracking Transparency implementation
   - Implement required system permissions handling
   - Add accessibility compliance

6. Configure in-app purchases (if applicable):
   - Create IAP products
   - Implement purchase flow with receipt validation
   - Add restore purchases functionality
   - Create subscription management interface

7. Prepare for App Review:
   - Create demo account for reviewers
   - Write review notes with testing instructions
   - Document edge cases and special features
   - Create content demonstrating app functionality

8. Implement App Store optimization:
   - Research competitive keywords
   - Create localized metadata for key markets
   - Optimize screenshots for conversion
   - Design preview video to showcase key features

9. Create release management:
   - Implement phased release strategy
   - Create post-launch monitoring plan
   - Design user feedback collection
   - Prepare for rapid fixes if needed

Ensure all App Store requirements are met while creating a compelling presentation that effectively communicates the app's value.

================
File: README.md
================
# Dusker - Surf Tracking App

Dusker is a comprehensive surf tracking application for Apple Watch and iPhone that helps surfers track their sessions, analyze their performance, and improve their surfing.

## Features

- Track surf sessions with detailed metrics
- Automatic wave detection
- Heart rate monitoring during sessions
- GPS tracking for distance and speed
- Session history and statistics
- Cross-device synchronization

## Requirements

- iOS 16.0+
- watchOS 9.0+
- Xcode 14.0+
- Swift 5.7+

## Project Structure

The project is organized into the following components:

- **iOS**: iPhone app
- **watchOS**: Apple Watch app
- **DuskerKit**: Shared framework for common code
- **Tests**: Unit and integration tests

## Getting Started

1. Clone the repository
2. Open the project in Xcode
3. Build and run the app on your device or simulator

## Development

The project uses SwiftUI for the user interface and follows the MVVM architecture pattern.

### Key Components

- **Models**: Data structures for surf sessions, waves, etc.
- **Views**: SwiftUI views for the user interface
- **ViewModels**: Business logic and data processing
- **Services**: Core functionality like location tracking, motion detection, etc.
- **Utilities**: Helper functions and extensions

## Testing

The project uses fastlane to automate running tests across all platforms.

### Setup

1. Make sure you have Ruby 3.2.2 installed:
   ```bash
   # Check Ruby version
   ruby -v
   
   # If needed, install with rbenv
   rbenv install 3.2.2
   rbenv local 3.2.2
   ```

2. Install dependencies:
   ```bash
   bundle install
   ```

### Running Tests

Run all tests (iOS, watchOS, and DuskerKit):
```bash
bundle exec fastlane test_all
```

Or run specific test suites:
```bash
# iOS tests only
bundle exec fastlane test_ios

# watchOS tests only
bundle exec fastlane test_watchos

# DuskerKit tests only
bundle exec fastlane test_kit
```

## License

This project is licensed under the MIT License - see the LICENSE file for details.

================
File: SimulatorConfig.xcconfig
================
// Standard simulator configurations for testing
IOS_SIMULATOR_NAME = iPhone 14
IOS_SIMULATOR_OS = 16.0
WATCHOS_SIMULATOR_NAME = Apple Watch Series 9 (45mm)
WATCHOS_SIMULATOR_OS = 10.0

================
File: spec.md
================
# Comprehensive Development Specification: Surf Tracking Apple Watch App

## 1. Project Overview

### 1.1 Purpose
To create a high-quality, reliable surf tracking application for Apple Watch that emphasizes care and craft in contrast to the current market leader, Dawn Patrol, which suffers from reliability issues and poor maintenance.

### 1.2 Vision Statement
A surf tracking app that surfers can depend on, with accurate wave detection and a clean, intuitive interface that focuses on core functionality rather than unnecessary features.

### 1.3 Target Platforms
- Primary: Apple Watch (watchOS)
- Companion: iPhone (iOS)
- Specific Support: Apple Watch Ultra (action button integration)

### 1.4 Development Approach
- Native SwiftUI for both watchOS and iOS components
- Single developer initially for both development and testing
- Iterative approach with no fixed timeline

## 2. Functional Requirements

### 2.1 Core Functionality

#### 2.1.1 Session Management
- **Start Session**
  - Manual start via button tap in app
  - Apple Watch Ultra Action Button support (user configures in system settings)
  - Auto-enables Water Lock mode on session start
- **End Session**
  - Manual stop via on-screen controls
  - Session data automatically saved locally
- **Session Sync**
  - Automatic background sync when possible
  - Manual sync when iPhone app is opened

#### 2.1.2 Wave Detection
- **Algorithm Components**
  - Combine accelerometer data to detect paddle-to-stand transition
  - Use gyroscope to confirm orientation change indicating standing
  - GPS speed thresholds to validate wave riding 
  - Motion pattern recognition to distinguish between paddling and riding
- **Sensitivity Settings**
  - User-selectable sensitivity with clear descriptions
  - Default to medium sensitivity with clear explanation of what each setting means

#### 2.1.3 Data Collection
- **Required Metrics**
  - Wave count
  - Distance surfed (total and per wave)
  - Session duration (total water time)
  - Distance paddled
  - Heart rate (min/avg/max)
  - Top speed
  - Stroke count
  - GPS tracks of each wave

#### 2.1.4 Location Detection
- **Spot Identification**
  - Compare GPS coordinates with known database of surf spots
  - Use reverse geocoding as fallback for unknown locations
  - Research potential API providers (Surfline, NOAA)

#### 2.1.5 Apple Health Integration
- **Workout Recording**
  - Record as "Surfing" workout type in Apple Health
  - Save active energy, heart rate data, and resting energy

### 2.2 User Interface Requirements

#### 2.2.1 Apple Watch App Screens
- **Pre-Session**
  - Simple start button
  - Current conditions display (if available)
- **Active Session**
  - Time elapsed (HH:MM:SS)
  - Wave count with wave icon
  - Distance surfed with ruler icon
  - Tide information (rising/falling indicator, next peak/nadir time)
  - Heart rate display (with color zones)
  - Swipe for additional metrics
- **Post-Session Review**
  - Multi-screen summary similar to provided screenshots
  - Health metrics display (heart rate)
  - Wave and distance stats
  - Activity ring progress

#### 2.2.2 iPhone Companion App
- **Session List**
  - Chronological listing of all sessions
  - Quick view of key metrics (waves, duration, location)
  - Sort/filter options
- **Session Detail**
  - Map view with wave tracks
  - Location name and timestamp
  - Tabbed interface (General, Insights, Waves)
  - Metric cards displaying:
    - Wave count
    - Longest wave distance
    - Best wave time
    - Top speed
    - Distance paddled
    - Stroke count
- **Sharing Interface**
  - Generate image with session map and metrics
  - Size options for different sharing contexts
  - No direct social integration, just image export

#### 2.2.3 Apple Watch Complications
- Wind direction
- Water temperature
- Tide information
- Swell size and direction
- Water level
- Sunset time

### 2.3 Data Requirements

#### 2.3.1 Local Storage
- CoreData for structured session storage
- Efficient storage of GPS coordinates for wave tracks
- Session metadata indexed for quick retrieval

#### 2.3.2 Cloud Sync
- iCloud integration for user data backup
- CloudKit for cross-device synchronization
- Encryption of sensitive location data

#### 2.3.3 External APIs
- Weather/conditions data provider (TBD, potentially Surfline)
- Tide data source
- Surf spot database integration

## 3. Non-Functional Requirements

### 3.1 Performance Requirements
- **Battery Efficiency**
  - Optimize GPS sampling rate during tracking
  - Implement intelligent sensor usage
  - Target: <20% battery usage per hour of tracking
- **App Responsiveness**
  - UI interactions respond within 100ms
  - Session start within 2 seconds of request
  - Background processing prioritized for accuracy over speed

### 3.2 Reliability Requirements
- **Wave Detection Accuracy**
  - Target >90% accuracy in wave detection
  - False positives preferred over missed waves
  - Consistent performance across different surf conditions
- **Data Preservation**
  - Auto-save capabilities for unexpected shutdowns
  - Recovery mechanisms for interrupted sessions
  - No data loss during sync operations

### 3.3 Privacy and Security
- **Data Storage**
  - All location data stored locally by default
  - Optional encrypted cloud backup
  - No data sharing with third parties
- **User Privacy**
  - Clear privacy policy for location handling
  - No tracking or analytics beyond crash reporting
  - Compliance with Apple privacy guidelines

## 4. Technical Architecture

### 4.1 High-Level Architecture
- **Watch App Components**
  - UI Layer (SwiftUI)
  - Session Manager Service
  - Sensor Data Service
  - Wave Detection Engine
  - Local Storage Manager
- **iPhone App Components**
  - UI Layer (SwiftUI)
  - Session Sync Service
  - Map Rendering Service
  - Analytics Engine
  - Export/Share Service

### 4.2 Data Flow
```
Watch Sensors → Sensor Service → Wave Detection Engine → Session Manager → Local Storage
                                                                    ↓
                                                            Health Kit API
                                                                    ↓
Local Storage ← Sync Service ← iCloud/CloudKit → Sync Service → iPhone Storage → UI Rendering
```

### 4.3 Key Algorithms
- **Wave Detection**
  1. Monitor accelerometer for paddle-to-stand transition pattern
  2. Confirm with gyroscope for board orientation change
  3. Validate with GPS speed increase
  4. Track duration using continued motion above threshold
  5. End wave detection when speed drops below threshold
- **GPS Track Processing**
  1. Filter erroneous GPS points
  2. Smooth wave tracks for display
  3. Calculate accurate distances despite potential GPS drift
- **Location Matching**
  1. Compare coordinates with known surf spot database
  2. Calculate confidence score based on proximity
  3. Fall back to reverse geocoding for unnamed locations

## 5. Implementation Plan

### 5.1 Development Phases
1. **Foundation (2-4 weeks)**
   - Set up project structure
   - Implement core watchOS UI
   - Basic sensor data collection
   - Session storage framework
2. **Core Features (4-6 weeks)**
   - Wave detection algorithm implementation
   - GPS track processing
   - Session review UI
   - Basic iPhone companion app
3. **Integration (2-3 weeks)**
   - HealthKit integration
   - Cloud sync implementation
   - Location detection
4. **Refinement (4+ weeks)**
   - Algorithm tuning
   - Performance optimization
   - UI polish
   - Extensive field testing

### 5.2 Testing Strategy
- **Unit Testing**
  - Core algorithm components
  - Data processing functions
  - Storage operations
- **Integration Testing**
  - Sensor data flow
  - Watch-to-phone sync
  - External API connections
- **Field Testing**
  - Real-world surf sessions in various conditions
  - Comparison against manual counting
  - Battery usage monitoring
  - Performance in challenging conditions (big waves, choppy water)

### 5.3 Validation Criteria
- Wave detection >90% accurate compared to manual counts
- Session data accurately syncs between devices
- Battery usage remains acceptable for 2+ hour sessions
- UI remains responsive throughout usage
- Storage efficiency allows for months of session history

## 6. API and Integration Details

### 6.1 Apple Frameworks
- **Required**
  - HealthKit: Store workout data
  - CoreLocation: GPS tracking and geofencing
  - CoreMotion: Accelerometer and gyroscope data
  - WatchKit: Apple Watch-specific functionality
  - CloudKit: iCloud synchronization
  - CoreData: Local data persistence
- **Optional**
  - BackgroundTasks: Background synchronization
  - WeatherKit: Basic weather data

### 6.2 External APIs
- **Weather/Swell Data**
  - API Selection TBD (Surfline if public API available)
  - Authentication requirements
  - Rate limiting considerations
  - Data caching strategy
- **Tide Information**
  - NOAA or similar public tide data
  - Pre-fetching for offline availability
  - Local calculation fallbacks

### 6.3 Integration Points
- **Apple Health**
  - Permission request handling
  - Workout session creation
  - HRV and energy data recording
- **Location Services**
  - Permission strategy (always/while using)
  - Background location handling
  - Battery optimization approaches

## 7. Error Handling Strategy

### 7.1 Critical Errors
- **Sensor Failures**
  - Fallback sensors where possible
  - User notification for critical sensor loss
  - Session continuation with reduced functionality
- **Storage Issues**
  - Temporary in-memory storage
  - Automatic retry mechanism
  - Recovery mode for corrupted data

### 7.2 Non-Critical Errors
- **Wave Detection Uncertainty**
  - Confidence ratings for detected waves
  - Optional review system for questionable detections
- **Connectivity Issues**
  - Offline mode with full functionality
  - Robust queue for sync operations
  - Conflict resolution strategy

### 7.3 Error Logging
- **Development Phase**
  - Comprehensive logging
  - Remote debugging capabilities
  - Sensor data recording for algorithm refinement
- **Production Phase**
  - Opt-in anonymized error reporting
  - Critical error tracking
  - Performance metrics collection

## 8. UI/UX Specifications

### 8.1 Design Language
- Clean, minimalist interface
- High contrast for outdoor visibility
- Tap targets optimized for wet finger interaction
- Consistent iconography

### 8.2 Color Palette
- Dark background (#0A1A2A) for main screens
- Bright accent colors for key information
- Orange highlights (#F89B45) for primary actions
- Performance metrics colorization (green/yellow/red) for heart rate

### 8.3 Typography
- San Francisco font family
- Large, readable type for watch interface
- Dynamic Type support for accessibility

### 8.4 Interface Components
- Custom wave counter visualization
- GPS track map renderer
- Metrics cards with consistent styling
- Action buttons with haptic feedback

## 9. Deployment Strategy

### 9.1 TestFlight
- Initial self-testing phase
- Expanded beta with trusted users
- Phased distribution approach

### 9.2 App Store
- Initial free release
- Potential future freemium model
- Distribution in surf-relevant markets first

### 9.3 Post-Launch Support
- Regular bug fix releases
- Quarterly feature updates
- User feedback collection mechanisms

## 10. Future Considerations

### 10.1 Potential Future Features
- More intuitive wave detection sensitivity
- Advanced stats and trends analysis
- Equipment logging
- Multiple user profiles
- Battery optimization features

### 10.2 Scalability Concerns
- Database performance with years of session data
- Cloud storage costs with increasing user base
- Algorithm refinement with diverse user data

## 11. Technical Debt Management
- Continuous refactoring schedule
- Code quality metrics tracking
- Technical documentation requirements
- Knowledge sharing approach

## 12. Appendix

### 12.1 Referenced Screenshots
- Dawn Patrol UI examples (for reference only)
- Initial UI mockups
- Data visualization examples

### 12.2 Required Resources
- Apple Developer Account
- External API access credentials
- Testing devices (various Apple Watch models)
- Development hardware requirements

================
File: todo.md
================
# Dusker App Development Checklist

## Phase 1: Foundation & Basic Structure

### Project Setup
- [ ] Initialize Xcode project with watchOS and iOS targets
- [ ] Configure project settings (iOS 16.0+, watchOS 9.0+)
- [ ] Set up SwiftUI as the UI framework
- [ ] Create folder structure (Models, Views, ViewModels, Services, Utilities, Extensions)
- [ ] Set up color palette (#0A1A2A background, #F89B45 accent, etc.)
- [ ] Create app icon placeholder
- [ ] Add required permission descriptions to Info.plist
- [ ] Set up version control
- [ ] Create basic XCTest structure

### Core Data Models
- [ ] Create CoreDataManager class
- [ ] Implement SurfSession entity with all attributes
- [ ] Implement Wave entity with all attributes
- [ ] Set up one-to-many relationship between SurfSession and Wave
- [ ] Create preview sample data
- [ ] Write unit tests for Core Data models

### Basic UI Navigation Structure
- [ ] Create watchOS MainView with navigation
- [ ] Implement watchOS SessionHistoryView
- [ ] Create watchOS SettingsView placeholder
- [ ] Implement watchOS session TabView
- [ ] Create iOS TabView with main sections
- [ ] Implement iOS SessionListView
- [ ] Create iOS SessionDetailView placeholder
- [ ] Implement shared ViewModifier for styling
- [ ] Set up preview providers for all views
- [ ] Write tests for navigation flow

### Local Storage Implementation
- [ ] Create PersistenceController singleton
- [ ] Implement CRUD operations for SurfSession
- [ ] Implement CRUD operations for Wave
- [ ] Create StorageManager protocol
- [ ] Implement CoreDataStorageManager
- [ ] Create custom StorageError handling
- [ ] Write unit tests for storage operations
- [ ] Create integration tests for UI and storage

## Phase 2: Sensor Data Collection

### Location Services
- [ ] Create LocationManager class with CLLocationManagerDelegate
- [ ] Implement location authorization handling
- [ ] Create GPSCoordinate struct
- [ ] Implement LocationPermissionService
- [ ] Configure background location updates
- [ ] Add location helper utilities
- [ ] Create location-related UI components
- [ ] Write tests for location services
- [ ] Implement mock location services for testing

### Motion Sensor Framework
- [ ] Create MotionManager class with CMMotionManager
- [ ] Implement MotionSample struct
- [ ] Create motion recording service
- [ ] Implement motion data processing utilities
- [ ] Add power management for motion sensors
- [ ] Update ViewModels to use motion data
- [ ] Write tests for motion processing
- [ ] Create mock motion services for testing

### Heart Rate Monitoring
- [ ] Create HeartRateManager using HKHealthStore
- [ ] Implement HeartRateSample struct
- [ ] Create heart rate visualization components
- [ ] Implement HealthKit authorization handling
- [ ] Add heart rate data analysis functions
- [ ] Update UI to display heart rate data
- [ ] Write tests for heart rate processing
- [ ] Create mock heart rate data for testing

### Sensor Data Integration
- [ ] Create SensorDataManager protocol
- [ ] Implement SensorDataManagerImpl class
- [ ] Create SensorDataSample combined struct
- [ ] Implement sensor data fusion algorithms
- [ ] Create SensorDataRecorder service
- [ ] Add diagnostic and calibration features
- [ ] Update SessionViewModel to use integrated sensors
- [ ] Write tests for sensor integration
- [ ] Create integration tests for all sensors

## Phase 3: Session Management

### Session Controller
- [ ] Create SessionController class
- [ ] Implement SessionState enum
- [ ] Create SessionViewModel
- [ ] Implement Water Lock integration
- [ ] Add Action Button support for Watch Ultra
- [ ] Create background session continuation
- [ ] Implement session persistence
- [ ] Write tests for session state management
- [ ] Create UI components for session control

### Basic Session UI
- [ ] Create watchOS SessionStartView
- [ ] Implement watchOS ActiveSessionView
- [ ] Create watchOS SessionEndView
- [ ] Implement iOS SessionSummaryView
- [ ] Create common UI components (MetricCard, WaveCounter, etc.)
- [ ] Add animations and transitions
- [ ] Implement accessibility features
- [ ] Create watch-specific UI adaptations
- [ ] Write UI tests for session workflows

### Session Storage
- [ ] Enhance SessionStore with auto-save
- [ ] Create SessionRepository protocol
- [ ] Implement CoreDataSessionRepository
- [ ] Create session filtering and sorting models
- [ ] Implement SessionHistoryViewModel
- [ ] Create iOS SessionHistoryView
- [ ] Implement watchOS SessionHistoryView
- [ ] Add session export functionality
- [ ] Write tests for session storage

### Session Metrics Calculation
- [ ] Create MetricsCalculator protocol
- [ ] Implement DefaultMetricsCalculator
- [ ] Create metrics data models
- [ ] Implement real-time metrics calculation
- [ ] Create summary metrics calculation
- [ ] Add visualization components
- [ ] Write tests for metrics calculation
- [ ] Create performance benchmarks

## Phase 4: Wave Detection Algorithm

### Motion Pattern Recognition
- [ ] Create MotionPatternRecognizer protocol
- [ ] Implement MachineLearningMotionRecognizer
- [ ] Create HeuristicMotionRecognizer
- [ ] Implement motion pattern data structures
- [ ] Create preprocessing pipeline
- [ ] Add motion pattern visualization
- [ ] Implement sensitivity settings
- [ ] Write tests for pattern recognition
- [ ] Create test data sets for validation

### Wave Detection Service
- [ ] Create WaveDetectionService protocol
- [ ] Implement DefaultWaveDetectionService
- [ ] Create WaveDetectionSettings struct
- [ ] Implement wave detection algorithm
- [ ] Create wave validation system
- [ ] Add wave detection visualization
- [ ] Implement wave storage integration
- [ ] Write tests for wave detection
- [ ] Create validation with recorded sessions

### Wave Storage and Retrieval
- [ ] Create WaveRepository protocol
- [ ] Implement CoreDataWaveRepository
- [ ] Create GPS track compression
- [ ] Implement WaveViewModel
- [ ] Create wave visualization components
- [ ] Add batch operations for waves
- [ ] Implement wave data analysis
- [ ] Create UI for wave management
- [ ] Write tests for wave storage

### Wave Detection Refinement
- [ ] Enhance WaveDetectionSettings with profiles
- [ ] Refine motion pattern detection
- [ ] Create wave detection debug mode
- [ ] Implement manual wave editing
- [ ] Add calibration workflows
- [ ] Enhance noise filtering
- [ ] Improve GPS integration
- [ ] Write tests for edge cases
- [ ] Create comprehensive validation suite

## Phase 5: HealthKit Integration

### HealthKit Authorization
- [ ] Create HealthKitManager class
- [ ] Implement permission requests
- [ ] Create HealthKitAuthorizationView
- [ ] Implement HealthKitViewModel
- [ ] Add authorization utilities
- [ ] Integrate with app settings
- [ ] Implement graceful degradation
- [ ] Write tests for authorization flows

### Workout Session Recording
- [ ] Create WorkoutSessionManager
- [ ] Implement WorkoutConfiguration
- [ ] Create LiveWorkoutDataStore
- [ ] Implement workout builders
- [ ] Add HealthKit sample generators
- [ ] Create workout summary
- [ ] Implement workout state synchronization
- [ ] Write tests for workout lifecycle

### Health Data Integration
- [ ] Create HealthDataIntegrator class
- [ ] Implement health data retrieval
- [ ] Create health-based insights
- [ ] Implement HealthInsightsView
- [ ] Add health data visualization
- [ ] Create health data dashboard
- [ ] Implement health data export
- [ ] Write tests for health integration

## Phase 6: iPhone Companion App

### Session List View
- [ ] Create SessionListViewModel
- [ ] Implement SessionListView
- [ ] Add filtering and sorting
- [ ] Implement list organization
- [ ] Add list interactions
- [ ] Create visual enhancements
- [ ] Implement search functionality
- [ ] Add list customization
- [ ] Write tests for list functionality

### Session Detail View
- [ ] Create SessionDetailViewModel
- [ ] Implement SessionDetailView with tabs
- [ ] Create Overview tab
- [ ] Implement Waves tab
- [ ] Create Insights tab
- [ ] Implement Health tab
- [ ] Add sharing functionality
- [ ] Implement editing capabilities
- [ ] Write tests for detail view

### Map Visualization
- [ ] Create SessionMapViewModel
- [ ] Implement SessionMapView with MapKit
- [ ] Create specialized map annotations
- [ ] Implement track visualization
- [ ] Add map control UI
- [ ] Create wave playback system
- [ ] Implement map optimization
- [ ] Add interactive features
- [ ] Write tests for map rendering

### Insights and Analytics
- [ ] Create AnalyticsEngine class
- [ ] Implement data analysis algorithms
- [ ] Create InsightsViewModel
- [ ] Implement visualization components
- [ ] Create insight categories
- [ ] Implement recommendation engine
- [ ] Create InsightsView
- [ ] Add goal tracking
- [ ] Write tests for analytics

## Phase 7: Device Synchronization

### iCloud Setup
- [ ] Create CloudKitManager class
- [ ] Define CloudKit record types
- [ ] Implement record conversion utilities
- [ ] Create sync token management
- [ ] Set up CloudKit subscriptions
- [ ] Create CloudKitSyncCoordinator
- [ ] Add sync UI components
- [ ] Implement sync privacy controls
- [ ] Write tests for iCloud operations

### Sync Service
- [ ] Create SyncService protocol
- [ ] Implement CloudKitSyncService
- [ ] Create sync data models
- [ ] Implement multi-stage sync process
- [ ] Create conflict resolution system
- [ ] Add background sync capabilities
- [ ] Implement error recovery
- [ ] Create sync monitoring
- [ ] Write tests for sync operations

### Cross-device Experience
- [ ] Implement Handoff support
- [ ] Create shared UI component library
- [ ] Implement settings synchronization
- [ ] Add Watch-to-Phone communication
- [ ] Create Continuity features
- [ ] Implement unified notification system
- [ ] Add shared state management
- [ ] Implement cross-device authentication
- [ ] Write tests for cross-device functionality

## Phase 8: External Data Integration

### Weather/Conditions API
- [ ] Create WeatherService protocol
- [ ] Implement API clients for providers
- [ ] Create weather and conditions models
- [ ] Implement data visualization components
- [ ] Create ConditionsViewModel
- [ ] Add location-based condition loading
- [ ] Implement forecast integration
- [ ] Create offline capabilities
- [ ] Write tests for weather integration

### Tide Information
- [ ] Create TideService protocol
- [ ] Implement NOAATideService
- [ ] Create alternative tide data sources
- [ ] Implement tide data models
- [ ] Create tide visualization components
- [ ] Implement TideViewModel
- [ ] Add session-specific tide integration
- [ ] Create tide complications for Watch
- [ ] Write tests for tide functionality

### Spot Identification
- [ ] Create SpotService protocol
- [ ] Implement spot database
- [ ] Create SpotIdentificationService
- [ ] Implement user-defined spots
- [ ] Create spot data models
- [ ] Implement spot visualization
- [ ] Create SpotViewModel
- [ ] Add spot analytics
- [ ] Write tests for spot identification

## Phase 9: Polish and Refinement

### UI Polish
- [ ] Create comprehensive design system
- [ ] Refine typography and text rendering
- [ ] Implement animations and transitions
- [ ] Polish watch-specific UI
- [ ] Enhance visual feedback
- [ ] Refine data visualization
- [ ] Improve loading states
- [ ] Polish layout and composition
- [ ] Write UI consistency tests

### Performance Optimization
- [ ] Implement intelligent sensor usage
- [ ] Optimize GPS usage
- [ ] Refine background processing
- [ ] Optimize UI rendering
- [ ] Improve data handling
- [ ] Create performance monitoring
- [ ] Add power saving modes
- [ ] Optimize network usage
- [ ] Write performance tests

### Error Handling
- [ ] Create unified error system
- [ ] Implement user-facing error presentation
- [ ] Create recovery mechanisms
- [ ] Handle device-specific errors
- [ ] Implement sensor error management
- [ ] Create network error handling
- [ ] Add background error management
- [ ] Implement diagnostic tools
- [ ] Write error handling tests

### Accessibility
- [ ] Implement VoiceOver support
- [ ] Enhance Dynamic Type support
- [ ] Add vision accommodations
- [ ] Implement motion accessibility
- [ ] Add hearing and speech accommodations
- [ ] Enhance motor control accessibility
- [ ] Design cognitive accessibility features
- [ ] Create accessibility settings
- [ ] Write accessibility tests

## Phase 10: Deployment Preparation

### Testing Infrastructure
- [ ] Implement unit testing framework
- [ ] Create mock system for testing
- [ ] Implement UI testing
- [ ] Create integration tests
- [ ] Implement performance testing
- [ ] Add sensor simulation
- [ ] Create test data sets
- [ ] Implement test automation
- [ ] Add specialized testing tools

### Documentation
- [ ] Implement code documentation
- [ ] Create architecture documentation
- [ ] Create API documentation
- [ ] Write developer guides
- [ ] Create user documentation
- [ ] Implement technical diagrams
- [ ] Add build and deployment documentation
- [ ] Create testing documentation
- [ ] Implement documentation automation

### TestFlight Preparation
- [ ] Configure app metadata
- [ ] Prepare beta testing assets
- [ ] Implement beta user management
- [ ] Add beta feedback mechanisms
- [ ] Create beta testing instructions
- [ ] Configure build settings
- [ ] Prepare analytics for beta
- [ ] Create beta release process
- [ ] Set up beta testing infrastructure

### App Store Submission
- [ ] Create App Store assets
- [ ] Write App Store metadata
- [ ] Configure app submission settings
- [ ] Prepare legal documentation
- [ ] Implement App Store requirements
- [ ] Configure in-app purchases (if applicable)
- [ ] Prepare for App Review
- [ ] Implement App Store optimization
- [ ] Create release management strategy



================================================================
End of Codebase
================================================================
